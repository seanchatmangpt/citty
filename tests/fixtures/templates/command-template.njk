/**
 * {{ command.label }}
 * {{ command.description }}
 * 
 * Generated from ontology: {{ command.id }}
 * Category: {{ command.category or 'general' }}
 */

import { defineCommand } from '../index';
{% if command.category %}
import { {{ command.category | camelCase }}Category } from '../categories/{{ command.category }}';
{% endif %}

{# Import any required utilities #}
{% for arg in command.arguments %}
  {% if arg.type == 'array' %}
import { parseArrayArgument } from '../utils/array-parser';
  {% endif %}
  {% if arg.enum %}
import { {{ arg.name | constantCase }}_OPTIONS } from '../constants/{{ arg.name | kebabCase }}-options';
  {% endif %}
{% endfor %}

{# Generate TypeScript interface for command arguments #}
export interface {{ command.name | pascalCase }}Args {
  {% for arg in command.arguments %}
  /** {{ arg.description }} */
  {{ arg.name | camelCase }}{% if not arg.required %}?{% endif %}: {{ arg.type | toTypeScriptType }}{% if arg.type == 'array' %}[]{% endif %};
  {% endfor %}
  
  // Inherited from {{ command.inheritsFrom or 'BaseCommand' }}
  {% if command.inheritedArguments %}
  {% for arg in command.inheritedArguments %}
  /** {{ arg.description }} (inherited) */
  {{ arg.name | camelCase }}{% if not arg.required %}?{% endif %}: {{ arg.type | toTypeScriptType }};
  {% endfor %}
  {% endif %}
}

{# Generate command result interface #}
export interface {{ command.name | pascalCase }}Result {
  success: boolean;
  data?: any;
  message?: string;
  errors?: string[];
  duration?: number;
}

{# Generate the main command definition #}
export const {{ command.name | camelCase }}Command = defineCommand({
  meta: {
    name: '{{ command.name | kebabCase }}',
    description: '{{ command.description }}',
    {% if command.category %}
    category: '{{ command.category }}',
    {% endif %}
    {% if command.alias %}
    alias: '{{ command.alias }}',
    {% endif %}
    {% if command.examples %}
    examples: [
      {% for example in command.examples %}
      '{{ example }}',
      {% endfor %}
    ],
    {% endif %}
    version: '1.0.0',
    author: 'Generated by Unjucks'
  },
  
  args: {
    {# Generate argument definitions #}
    {% for arg in command.arguments %}
    {{ arg.name | camelCase }}: {
      type: '{{ arg.type }}',
      description: '{{ arg.description }}',
      {% if arg.required %}
      required: true,
      {% endif %}
      {% if arg.default is defined %}
      default: {{ arg.default | tojson }},
      {% endif %}
      {% if arg.enum %}
      choices: {{ arg.enum | tojson }},
      {% endif %}
      {% if arg.min is defined %}
      min: {{ arg.min }},
      {% endif %}
      {% if arg.max is defined %}
      max: {{ arg.max }},
      {% endif %}
      {% if arg.variadic %}
      variadic: true,
      {% endif %}
      {% if arg.type == 'string' and arg.pattern %}
      pattern: new RegExp('{{ arg.pattern }}'),
      {% endif %}
      {% if arg.valueHint %}
      valueHint: '{{ arg.valueHint }}',
      {% endif %}
    },
    {% endfor %}
    
    {# Include inherited arguments if any #}
    {% if command.inheritedArguments %}
    // Inherited arguments from {{ command.inheritsFrom }}
    {% for arg in command.inheritedArguments %}
    {{ arg.name | camelCase }}: {
      type: '{{ arg.type }}',
      description: '{{ arg.description }} (inherited)',
      {% if arg.required %}
      required: true,
      {% endif %}
      {% if arg.default is defined %}
      default: {{ arg.default | tojson }},
      {% endif %}
    },
    {% endfor %}
    {% endif %}
  },
  
  {# Pre-execution hooks #}
  async setup({ args, meta }) {
    // Pre-execution setup
    console.log(`Setting up ${meta.name}...`);
    
    {% if command.category == 'database' %}
    // Database-specific setup
    await ensureDatabaseConnection();
    {% elif command.category == 'deployment' %}
    // Deployment-specific setup
    await validateDeploymentCredentials();
    {% endif %}
    
    // Validate arguments
    {% for arg in command.arguments %}
    {% if arg.required %}
    if (!args.{{ arg.name | camelCase }}) {
      throw new Error('{{ arg.name }} is required');
    }
    {% endif %}
    {% if arg.enum %}
    if (args.{{ arg.name | camelCase }} && !{{ arg.name | constantCase }}_OPTIONS.includes(args.{{ arg.name | camelCase }})) {
      throw new Error(`Invalid {{ arg.name }}: ${args.{{ arg.name | camelCase }}}. Must be one of: ${{{ arg.name | constantCase }}_OPTIONS.join(', ')}`);
    }
    {% endif %}
    {% endfor %}
  },
  
  {# Main execution function #}
  async run({ args, meta }): Promise<{{ command.name | pascalCase }}Result> {
    const startTime = Date.now();
    
    try {
      console.log(`Executing ${meta.name} with arguments:`, args);
      
      {# Generate command-specific implementation based on name #}
      {% if command.name | lower | includes('build') %}
      // Build implementation
      console.log('Starting build process...');
      
      {% if 'target' in command.arguments | map(attribute='name') %}
      const buildTarget = args.target || './dist';
      console.log(`Building to target: ${buildTarget}`);
      {% endif %}
      
      {% if 'production' in command.arguments | map(attribute='name') %}
      if (args.production) {
        console.log('Building for production environment');
        // Production-specific build logic
      } else {
        console.log('Building for development environment');
        // Development-specific build logic
      }
      {% endif %}
      
      {% if 'watch' in command.arguments | map(attribute='name') %}
      if (args.watch) {
        console.log('Watch mode enabled - monitoring for changes');
        // Implement file watching logic
      }
      {% endif %}
      
      {% elif command.name | lower | includes('test') %}
      // Test implementation
      console.log('Running tests...');
      
      {% if 'pattern' in command.arguments | map(attribute='name') %}
      const testPattern = args.pattern || '**/*.test.{ts,js}';
      console.log(`Using test pattern: ${testPattern}`);
      {% endif %}
      
      {% if 'coverage' in command.arguments | map(attribute='name') %}
      if (args.coverage) {
        console.log('Generating coverage report');
        // Coverage reporting logic
      }
      {% endif %}
      
      {% elif command.name | lower | includes('serve') %}
      // Server implementation
      {% if 'port' in command.arguments | map(attribute='name') %}
      const port = args.port || 3000;
      {% endif %}
      {% if 'host' in command.arguments | map(attribute='name') %}
      const host = args.host || 'localhost';
      {% endif %}
      
      {% if 'https' in command.arguments | map(attribute='name') %}
      const protocol = args.https ? 'https' : 'http';
      console.log(`Starting server at ${protocol}://${host}:${port}`);
      {% endif %}
      
      {% if 'openBrowser' in command.arguments | map(attribute='name') %}
      if (args.openBrowser) {
        console.log('Opening browser...');
        // Browser opening logic
      }
      {% endif %}
      
      {% elif command.name | lower | includes('deploy') %}
      // Deployment implementation
      {% if 'environment' in command.arguments | map(attribute='name') %}
      const environment = args.environment;
      console.log(`Deploying to ${environment} environment`);
      {% endif %}
      
      {% if 'dryRun' in command.arguments | map(attribute='name') %}
      if (args.dryRun) {
        console.log('DRY RUN MODE - No actual deployment will occur');
        // Dry run logic
        return {
          success: true,
          message: `Dry run deployment to ${environment} completed successfully`,
          duration: Date.now() - startTime
        };
      }
      {% endif %}
      
      {% elif command.name | lower | includes('lint') %}
      // Linting implementation
      {% if 'files' in command.arguments | map(attribute='name') %}
      const filesToLint = Array.isArray(args.files) ? args.files : [args.files];
      console.log(`Linting files: ${filesToLint.join(', ')}`);
      {% endif %}
      
      {% if 'fix' in command.arguments | map(attribute='name') %}
      if (args.fix) {
        console.log('Auto-fix mode enabled');
        // Auto-fix logic
      }
      {% endif %}
      
      {% elif command.name | lower | includes('migrate') %}
      // Database migration implementation
      {% if 'direction' in command.arguments | map(attribute='name') %}
      const direction = args.direction || 'up';
      console.log(`Running migration ${direction}`);
      {% endif %}
      
      {% if 'steps' in command.arguments | map(attribute='name') %}
      const steps = args.steps;
      if (steps) {
        console.log(`Running ${steps} migration steps`);
      }
      {% endif %}
      
      {% else %}
      // Generic command implementation
      console.log('Executing {{ command.name }}...');
      
      // Process arguments
      {% for arg in command.arguments %}
      if (args.{{ arg.name | camelCase }}) {
        console.log('{{ arg.label }}:', args.{{ arg.name | camelCase }});
      }
      {% endfor %}
      {% endif %}
      
      {# Common verbose handling #}
      {% if 'verbose' in (command.arguments | map(attribute='name')) or 'verbose' in (command.inheritedArguments | map(attribute='name')) %}
      if (args.verbose) {
        console.log('Verbose mode enabled');
        console.log('Detailed execution information...');
      }
      {% endif %}
      
      {# Common config handling #}
      {% if 'config' in (command.arguments | map(attribute='name')) or 'config' in (command.inheritedArguments | map(attribute='name')) %}
      if (args.config) {
        console.log(`Using configuration file: ${args.config}`);
        // Load and apply configuration
      }
      {% endif %}
      
      // Simulate work (replace with actual implementation)
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const duration = Date.now() - startTime;
      console.log(`${meta.name} completed successfully in ${duration}ms`);
      
      return {
        success: true,
        message: `${meta.name} executed successfully`,
        duration
      };
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`${meta.name} failed:`, error);
      
      return {
        success: false,
        message: `${meta.name} failed: ${error.message}`,
        errors: [error.message],
        duration
      };
    }
  },
  
  {# Post-execution cleanup #}
  async cleanup({ args, meta, result }) {
    console.log(`Cleaning up after ${meta.name}...`);
    
    {% if command.category == 'database' %}
    // Database-specific cleanup
    await closeDatabaseConnection();
    {% endif %}
    
    if (!result.success) {
      console.log('Command failed - performing error cleanup');
    }
  }
});

{# Export convenience functions #}
export async function {{ command.name | camelCase }}(
  args: Partial<{{ command.name | pascalCase }}Args>
): Promise<{{ command.name | pascalCase }}Result> {
  return await {{ command.name | camelCase }}Command.run({ args: args as any, meta: {{ command.name | camelCase }}Command.meta });
}

{# Generate validation helpers #}
export function validate{{ command.name | pascalCase }}Args(
  args: any
): args is {{ command.name | pascalCase }}Args {
  {% for arg in command.arguments %}
  {% if arg.required %}
  if (!args.{{ arg.name | camelCase }}) {
    throw new Error('{{ arg.name }} is required');
  }
  {% endif %}
  
  {% if arg.type == 'number' %}
  if (args.{{ arg.name | camelCase }} !== undefined && typeof args.{{ arg.name | camelCase }} !== 'number') {
    throw new Error('{{ arg.name }} must be a number');
  }
  {% if arg.min is defined %}
  if (args.{{ arg.name | camelCase }} < {{ arg.min }}) {
    throw new Error('{{ arg.name }} must be at least {{ arg.min }}');
  }
  {% endif %}
  {% if arg.max is defined %}
  if (args.{{ arg.name | camelCase }} > {{ arg.max }}) {
    throw new Error('{{ arg.name }} must be at most {{ arg.max }}');
  }
  {% endif %}
  {% elif arg.type == 'string' %}
  if (args.{{ arg.name | camelCase }} !== undefined && typeof args.{{ arg.name | camelCase }} !== 'string') {
    throw new Error('{{ arg.name }} must be a string');
  }
  {% elif arg.type == 'boolean' %}
  if (args.{{ arg.name | camelCase }} !== undefined && typeof args.{{ arg.name | camelCase }} !== 'boolean') {
    throw new Error('{{ arg.name }} must be a boolean');
  }
  {% elif arg.type == 'array' %}
  if (args.{{ arg.name | camelCase }} !== undefined && !Array.isArray(args.{{ arg.name | camelCase }})) {
    throw new Error('{{ arg.name }} must be an array');
  }
  {% endif %}
  {% endfor %}
  
  return true;
}

{# Export command metadata for introspection #}
export const {{ command.name | camelCase }}Metadata = {
  name: '{{ command.name }}',
  label: '{{ command.label }}',
  description: '{{ command.description }}',
  category: '{{ command.category or 'general' }}',
  {% if command.alias %}
  alias: '{{ command.alias }}',
  {% endif %}
  ontologyId: '{{ command.id }}',
  {% if command.inheritsFrom %}
  inheritsFrom: '{{ command.inheritsFrom }}',
  {% endif %}
  arguments: [
    {% for arg in command.arguments %}
    {
      name: '{{ arg.name }}',
      label: '{{ arg.label }}',
      description: '{{ arg.description }}',
      type: '{{ arg.type }}',
      required: {{ arg.required | tojson }},
      {% if arg.default is defined %}
      default: {{ arg.default | tojson }},
      {% endif %}
      {% if arg.enum %}
      enum: {{ arg.enum | tojson }},
      {% endif %}
    },
    {% endfor %}
  ],
  generated: {
    timestamp: '{{ "now" | date("ISO") }}',
    by: 'unjucks-template-engine',
    version: '1.0.0'
  }
} as const;
