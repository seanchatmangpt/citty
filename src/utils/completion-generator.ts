/**
 * Shell completion script generator for various shells
 */
import type { CommandDef, ArgsDef } from '../types.js';
import { resolveArgs } from '../args.js';
import { resolveValue } from '../_utils.js';

export class CompletionGenerator {
  /**
   * Generate completion script for the specified shell
   */
  async generateCompletion(
    cmd: CommandDef,
    shell: 'bash' | 'zsh' | 'fish' | 'powershell',
    programName: string = 'unjucks'
  ): Promise<string> {
    const cmdMeta = await resolveValue(cmd.meta || {});
    const cmdArgs = resolveArgs(await resolveValue(cmd.args || {}));
    
    switch (shell) {
      case 'bash':
        return this.generateBashCompletion(programName, cmdMeta, cmdArgs, cmd);
      case 'zsh':
        return this.generateZshCompletion(programName, cmdMeta, cmdArgs, cmd);
      case 'fish':
        return this.generateFishCompletion(programName, cmdMeta, cmdArgs, cmd);
      case 'powershell':
        return this.generatePowerShellCompletion(programName, cmdMeta, cmdArgs, cmd);
      default:
        throw new Error(`Unsupported shell: ${shell}`);
    }
  }

  /**
   * Generate Bash completion script
   */
  private async generateBashCompletion(
    programName: string,
    meta: any,
    args: any[],
    cmd: CommandDef
  ): Promise<string> {
    const subCommands = cmd.subCommands ? await resolveValue(cmd.subCommands) : {};
    const subCommandNames = Object.keys(subCommands);
    
    const options = args
      .filter(arg => arg.type !== 'positional')
      .map(arg => {
        const aliases = (arg.alias || []).map((a: string) => `-${a}`);
        return [`--${arg.name}`, ...aliases].join(' ');
      })
      .join(' ');

    const enumOptions = args
      .filter(arg => arg.type === 'enum' && arg.options)
      .map(arg => `
        --${arg.name})
          COMPREPLY=($(compgen -W "${arg.options.join(' ')}" -- "$cur"))
          return 0
          ;;`)
      .join('\\n');

    return `#!/usr/bin/env bash
# ${programName} bash completion script
# Generated by unjucks completion generator

_${programName}_completion() {
  local cur prev words cword
  _init_completion || return

  # Handle subcommands
  local subcommands="${subCommandNames.join(' ')}"
  
  # Handle options
  local options="${options}"

  case "$prev" in
    ${enumOptions}
    --output|-o)
      COMPREPLY=($(compgen -f -- "$cur"))
      return 0
      ;;
    --context|-c)
      COMPREPLY=($(compgen -f -X '!*.@(json|yaml|yml)' -- "$cur"))
      return 0
      ;;
    --ontology)
      COMPREPLY=($(compgen -f -X '!*.@(json|rdf|ttl)' -- "$cur"))
      return 0
      ;;
    --template-dir|-t)
      COMPREPLY=($(compgen -d -- "$cur"))
      return 0
      ;;
  esac

  # Complete subcommands and options
  if [[ "$cur" == -* ]]; then
    COMPREPLY=($(compgen -W "$options" -- "$cur"))
  else
    # Try to complete generators and actions
    local generators
    if command -v ${programName} &> /dev/null; then
      generators=$(${programName} --list 2>/dev/null | grep "^üìÅ" | sed 's/^üìÅ //')
    fi
    
    # Complete subcommands first, then generators
    COMPREPLY=($(compgen -W "$subcommands $generators" -- "$cur"))
  fi
}

# Register the completion
complete -F _${programName}_completion ${programName}

# Installation instructions as comment:
# To enable completion, add this to your ~/.bashrc or ~/.bash_profile:
# eval "$(${programName} --completion=bash)"
`;
  }

  /**
   * Generate Zsh completion script
   */
  private async generateZshCompletion(
    programName: string,
    meta: any,
    args: any[],
    cmd: CommandDef
  ): Promise<string> {
    const subCommands = cmd.subCommands ? await resolveValue(cmd.subCommands) : {};
    const subCommandNames = Object.keys(subCommands);

    const optionSpecs = args
      .filter(arg => arg.type !== 'positional')
      .map(arg => {
        const aliases = (arg.alias || []).map((a: string) => `-${a}`);
        const allNames = [`--${arg.name}`, ...aliases];
        
        let spec = `'${allNames.join(',')}'`;
        
        if (arg.type === 'string') {
          if (arg.name === 'output') {
            spec += '[Output file]:file:_files';
          } else if (arg.name === 'context') {
            spec += '[Context file]:file:_files -g "*.json *.yaml *.yml"';
          } else if (arg.name === 'ontology') {
            spec += '[Ontology file]:file:_files -g "*.json *.rdf *.ttl"';
          } else if (arg.name === 'template-dir') {
            spec += '[Template directory]:directory:_directories';
          } else {
            spec += `[${arg.description || arg.name}]:string:`;
          }
        } else if (arg.type === 'enum' && arg.options) {
          spec += `[${arg.description || arg.name}]:option:(${arg.options.join(' ')})`;
        } else {
          spec += `[${arg.description || arg.name}]`;
        }
        
        return spec;
      });

    return `#compdef ${programName}
# ${programName} zsh completion script
# Generated by unjucks completion generator

_${programName}() {
  local context state line
  typeset -A opt_args

  # Define generators function
  _generators() {
    local generators
    generators=($(${programName} --list 2>/dev/null | grep "^üìÅ" | sed 's/^üìÅ //'))
    _describe 'generators' generators
  }

  # Define actions function
  _actions() {
    # This would need the selected generator to list actions
    # For now, provide common actions
    local actions=('create' 'update' 'generate' 'scaffold' 'delete')
    _describe 'actions' actions
  }

  _arguments -C \\
    ${optionSpecs.map(spec => `    ${spec} \\\\`).join('\\n')}
    '1:generator:_generators' \\
    '2:action:_actions' \\
    '*::args:->args'

  case $state in
    args)
      # Additional completion logic for remaining arguments
      ;;
  esac
}

# Subcommands completion
${subCommandNames.map(sub => `
_${programName}_${sub}() {
  # Specific completion for ${sub} subcommand
  _arguments \\
    '--help[Show help for ${sub}]' \\
    '*::args:_files'
}`).join('\\n')}

_${programName} "$@"

# Installation instructions as comment:
# To enable completion, add this to your ~/.zshrc:
# eval "$(${programName} --completion=zsh)"
`;
  }

  /**
   * Generate Fish completion script
   */
  private async generateFishCompletion(
    programName: string,
    meta: any,
    args: any[],
    cmd: CommandDef
  ): Promise<string> {
    const subCommands = cmd.subCommands ? await resolveValue(cmd.subCommands) : {};
    const subCommandNames = Object.keys(subCommands);

    const optionCompletions = args
      .filter(arg => arg.type !== 'positional')
      .map(arg => {
        const longOption = `--${arg.name}`;
        const shortOption = arg.alias && arg.alias.length > 0 ? `-${arg.alias[0]}` : '';
        
        let completion = `complete -c ${programName} -l ${arg.name}`;
        
        if (shortOption) {
          completion += ` -s ${arg.alias[0]}`;
        }
        
        if (arg.description) {
          completion += ` -d "${arg.description.replace(/"/g, '\\\\"')}"`;
        }

        // Add argument completion based on type
        if (arg.type === 'string') {
          if (arg.name === 'output') {
            completion += ' -r -F'; // Require argument, complete files
          } else if (arg.name === 'context') {
            completion += ' -r -k -a "(find . -name \'*.json\' -o -name \'*.yaml\' -o -name \'*.yml\' 2>/dev/null)"';
          } else if (arg.name === 'template-dir') {
            completion += ' -r -a "(__fish_complete_directories)"';
          } else {
            completion += ' -r'; // Require argument
          }
        } else if (arg.type === 'enum' && arg.options) {
          completion += ` -r -a "${arg.options.join(' ')}"`;
        }
        
        return completion;
      });

    const subCommandCompletions = subCommandNames.map(sub => 
      `complete -c ${programName} -n '__fish_use_subcommand' -a ${sub} -d 'Run ${sub} command'`
    );

    return `# ${programName} fish completion script
# Generated by unjucks completion generator

# Remove any existing completions
complete -c ${programName} -e

# Main command options
${optionCompletions.join('\\n')}

# Subcommands
${subCommandCompletions.join('\\n')}

# Generator completion
complete -c ${programName} -n '__fish_use_subcommand' -a "(${programName} --list 2>/dev/null | grep '^üìÅ' | sed 's/^üìÅ //')" -d 'Available generators'

# Context-sensitive completion
complete -c ${programName} -n '__fish_seen_subcommand_from init' -l force -s f -d 'Overwrite existing files'
complete -c ${programName} -n '__fish_seen_subcommand_from validate' -l template-dir -s t -r -a "(__fish_complete_directories)" -d 'Template directory'
complete -c ${programName} -n '__fish_seen_subcommand_from validate' -l ontology -s o -r -F -d 'Ontology file'

# File type completions
complete -c ${programName} -s o -l output -r -F -d 'Output file'
complete -c ${programName} -s c -l context -r -k -a "(find . -name '*.json' -o -name '*.yaml' -o -name '*.yml' 2>/dev/null)" -d 'Context file'

# Installation instructions as comment:
# To enable completion, add this to your ~/.config/fish/config.fish:
# ${programName} --completion=fish | source
`;
  }

  /**
   * Generate PowerShell completion script
   */
  private async generatePowerShellCompletion(
    programName: string,
    meta: any,
    args: any[],
    cmd: CommandDef
  ): Promise<string> {
    const subCommands = cmd.subCommands ? await resolveValue(cmd.subCommands) : {};
    const subCommandNames = Object.keys(subCommands);

    const parameterCompletions = args
      .filter(arg => arg.type !== 'positional')
      .map(arg => {
        const paramName = arg.name;
        
        if (arg.type === 'enum' && arg.options) {
          return `        '${paramName}' { @(${arg.options.map(opt => `'${opt}'`).join(', ')}) }`;
        } else if (arg.name === 'context') {
          return `        '${paramName}' { Get-ChildItem -Path . -Include *.json,*.yaml,*.yml -Recurse | Select-Object -ExpandProperty Name }`;
        } else if (arg.name === 'template-dir') {
          return `        '${paramName}' { Get-ChildItem -Path . -Directory | Select-Object -ExpandProperty Name }`;
        }
        
        return `        '${paramName}' { @() }`; // Empty completion
      })
      .join('\\n');

    return `# ${programName} PowerShell completion script
# Generated by unjucks completion generator

Register-ArgumentCompleter -CommandName ${programName} -ScriptBlock {
    param($commandName, $wordToComplete, $cursorPosition)
    
    # Get all arguments up to cursor
    $arguments = $wordToComplete -split ' '
    
    # Subcommands
    $subCommands = @(${subCommandNames.map(name => `'${name}'`).join(', ')})
    
    # Options
    $options = @(${args
      .filter(arg => arg.type !== 'positional')
      .map(arg => `'--${arg.name}'`)
      .join(', ')})
    
    # Handle parameter completion
    if ($wordToComplete -match '^--?(.+)=(.*)$') {
        $paramName = $matches[1]
        $paramValue = $matches[2]
        
        switch ($paramName) {
${parameterCompletions}
            default { @() }
        }
    }
    # Handle option completion
    elseif ($wordToComplete.StartsWith('-')) {
        $options | Where-Object { $_ -like "$wordToComplete*" }
    }
    # Handle command/generator completion
    else {
        $completions = @()
        
        # Add subcommands
        $completions += $subCommands | Where-Object { $_ -like "$wordToComplete*" }
        
        # Add generators (if available)
        try {
            $generators = & ${programName} --list 2>$null | Select-String "^üìÅ " | ForEach-Object { $_.ToString().Substring(3) }
            $completions += $generators | Where-Object { $_ -like "$wordToComplete*" }
        }
        catch {
            # Ignore errors when getting generators
        }
        
        $completions
    }
}

# Installation instructions as comment:
# To enable completion, add this to your PowerShell profile:
# & ${programName} --completion=powershell | Invoke-Expression
# 
# To find your profile location, run: $PROFILE
`;
  }

  /**
   * Get installation instructions for the specified shell
   */
  getInstallationInstructions(shell: 'bash' | 'zsh' | 'fish' | 'powershell', programName: string = 'unjucks'): string {
    const instructions = {
      bash: `# Add to ~/.bashrc or ~/.bash_profile:
eval "$(${programName} --completion=bash)"

# Or save to completion directory:
${programName} --completion=bash > /usr/local/share/bash-completion/completions/${programName}`,

      zsh: `# Add to ~/.zshrc:
eval "$(${programName} --completion=zsh)"

# Or save to completion directory:
${programName} --completion=zsh > ~/.oh-my-zsh/completions/_${programName}`,

      fish: `# Add to ~/.config/fish/config.fish:
${programName} --completion=fish | source

# Or save to completion directory:
${programName} --completion=fish > ~/.config/fish/completions/${programName}.fish`,

      powershell: `# Add to PowerShell profile (run $PROFILE to find location):
& ${programName} --completion=powershell | Invoke-Expression

# Or save to a file and dot-source it:
${programName} --completion=powershell > ${programName}-completion.ps1
. ./${programName}-completion.ps1`
    };

    return instructions[shell];
  }
}
export { CompletionGenerator };
