/**\n * ðŸ”Œ Plugin Architecture: Extensible Hook System\n * Comprehensive plugin framework with lifecycle hooks, dependency injection,\n * and event-driven architecture for ecosystem integration\n */\n\nimport { EventEmitter } from 'events'\nimport { resolve, dirname } from 'pathe'\nimport { existsSync } from 'node:fs'\nimport { readFile } from 'node:fs/promises'\nimport { defu } from 'defu'\nimport { MemoryCache } from '../cache'\n\n/**\n * Plugin metadata and configuration\n */\nexport interface PluginMetadata {\n  name: string\n  version: string\n  description?: string\n  author?: string\n  homepage?: string\n  repository?: string\n  license?: string\n  keywords?: string[]\n  dependencies?: string[]\n  peerDependencies?: string[]\n  engines?: {\n    node?: string\n    unjucks?: string\n  }\n}\n\n/**\n * Plugin configuration options\n */\nexport interface PluginOptions {\n  enabled?: boolean\n  priority?: number\n  config?: Record<string, any>\n  environment?: 'development' | 'production' | 'test'\n  lazy?: boolean\n  singleton?: boolean\n}\n\n/**\n * Plugin lifecycle hooks\n */\nexport interface PluginHooks {\n  // System lifecycle\n  'system:init'?: (context: PluginContext) => Promise<void> | void\n  'system:ready'?: (context: PluginContext) => Promise<void> | void\n  'system:destroy'?: (context: PluginContext) => Promise<void> | void\n  \n  // Template lifecycle\n  'template:before-load'?: (templatePath: string, context: PluginContext) => Promise<string> | string\n  'template:after-load'?: (template: any, context: PluginContext) => Promise<any> | any\n  'template:before-render'?: (template: any, context: any, pluginContext: PluginContext) => Promise<any> | any\n  'template:after-render'?: (result: any, context: PluginContext) => Promise<any> | any\n  \n  // Ontology lifecycle\n  'ontology:before-load'?: (ontologySource: string, context: PluginContext) => Promise<string> | string\n  'ontology:after-load'?: (ontology: any, context: PluginContext) => Promise<any> | any\n  'ontology:context-transform'?: (context: any, pluginContext: PluginContext) => Promise<any> | any\n  \n  // Build lifecycle\n  'build:before'?: (context: PluginContext) => Promise<void> | void\n  'build:after'?: (result: any, context: PluginContext) => Promise<void> | void\n  \n  // Development lifecycle\n  'dev:server-start'?: (server: any, context: PluginContext) => Promise<void> | void\n  'dev:file-change'?: (filePath: string, context: PluginContext) => Promise<void> | void\n  'dev:hot-reload'?: (context: PluginContext) => Promise<void> | void\n  \n  // Custom hooks (extensible)\n  [key: string]: ((context: PluginContext, ...args: any[]) => Promise<any> | any) | undefined\n}\n\n/**\n * Plugin context passed to hooks\n */\nexport interface PluginContext {\n  plugin: Plugin\n  manager: PluginManager\n  config: any\n  logger: PluginLogger\n  cache: MemoryCache<any>\n  utils: PluginUtils\n  services: Map<string, any>\n}\n\n/**\n * Plugin logger interface\n */\nexport interface PluginLogger {\n  debug(message: string, ...args: any[]): void\n  info(message: string, ...args: any[]): void\n  warn(message: string, ...args: any[]): void\n  error(message: string, error?: Error, ...args: any[]): void\n}\n\n/**\n * Plugin utilities\n */\nexport interface PluginUtils {\n  resolve(path: string): string\n  requireModule(id: string): any\n  loadJson(path: string): Promise<any>\n  writeJson(path: string, data: any): Promise<void>\n  glob(pattern: string, cwd?: string): Promise<string[]>\n  isFile(path: string): Promise<boolean>\n  isDirectory(path: string): Promise<boolean>\n}\n\n/**\n * Plugin definition interface\n */\nexport interface Plugin {\n  metadata: PluginMetadata\n  options: PluginOptions\n  hooks: PluginHooks\n  context?: PluginContext\n  instance?: any\n  \n  // Plugin factory function\n  factory?: (context: PluginContext) => PluginHooks | Promise<PluginHooks>\n  \n  // Plugin class constructor\n  PluginClass?: new (context: PluginContext) => PluginHooks\n  \n  // Direct hooks object\n  setup?: (context: PluginContext) => Promise<void> | void\n  teardown?: (context: PluginContext) => Promise<void> | void\n}\n\n/**\n * Plugin manager configuration\n */\nexport interface PluginManagerOptions {\n  /**\n   * Plugin search paths\n   * @default ['./plugins', './node_modules']\n   */\n  searchPaths?: string[]\n  \n  /**\n   * Auto-discover plugins\n   * @default true\n   */\n  autoDiscover?: boolean\n  \n  /**\n   * Plugin prefix for auto-discovery\n   * @default 'unjucks-plugin-'\n   */\n  pluginPrefix?: string\n  \n  /**\n   * Maximum execution time for hooks (ms)\n   * @default 30000\n   */\n  hookTimeout?: number\n  \n  /**\n   * Enable plugin caching\n   * @default true\n   */\n  enableCache?: boolean\n  \n  /**\n   * Development mode features\n   * @default false\n   */\n  development?: boolean\n  \n  /**\n   * Global plugin configuration\n   */\n  globalConfig?: Record<string, any>\n}\n\n/**\n * Main plugin manager class\n */\nexport class PluginManager extends EventEmitter {\n  private options: Required<PluginManagerOptions>\n  private plugins = new Map<string, Plugin>()\n  private loadedPlugins = new Set<string>()\n  private cache: MemoryCache<any>\n  private services = new Map<string, any>()\n  private logger: PluginLogger\n  private utils: PluginUtils\n  \n  constructor(options: PluginManagerOptions = {}) {\n    super()\n    \n    this.options = defu(options, {\n      searchPaths: ['./plugins', './node_modules'],\n      autoDiscover: true,\n      pluginPrefix: 'unjucks-plugin-',\n      hookTimeout: 30000,\n      enableCache: true,\n      development: process.env.NODE_ENV === 'development',\n      globalConfig: {}\n    })\n    \n    this.cache = new MemoryCache({ defaultTtl: 0 }) // No TTL for plugin cache\n    this.logger = this.createLogger()\n    this.utils = this.createUtils()\n    \n    this.setupErrorHandling()\n  }\n  \n  /**\n   * Initialize plugin manager\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing plugin manager...')\n    \n    try {\n      // Auto-discover plugins if enabled\n      if (this.options.autoDiscover) {\n        await this.discoverPlugins()\n      }\n      \n      // Load all registered plugins\n      await this.loadAllPlugins()\n      \n      // Execute system:init hooks\n      await this.executeHook('system:init')\n      \n      // Execute system:ready hooks\n      await this.executeHook('system:ready')\n      \n      this.logger.info(`Plugin manager initialized with ${this.plugins.size} plugins`)\n      this.emit('initialized')\n      \n    } catch (error) {\n      this.logger.error('Failed to initialize plugin manager', error as Error)\n      throw error\n    }\n  }\n  \n  /**\n   * Register a plugin\n   */\n  registerPlugin(plugin: Plugin): void {\n    const name = plugin.metadata.name\n    \n    // Validate plugin metadata\n    this.validatePlugin(plugin)\n    \n    // Check for conflicts\n    if (this.plugins.has(name)) {\n      if (this.options.development) {\n        this.logger.warn(`Plugin ${name} is already registered, replacing...`)\n      } else {\n        throw new Error(`Plugin ${name} is already registered`)\n      }\n    }\n    \n    // Set default options\n    plugin.options = defu(plugin.options, {\n      enabled: true,\n      priority: 0,\n      config: {},\n      environment: process.env.NODE_ENV as any || 'development',\n      lazy: false,\n      singleton: true\n    })\n    \n    this.plugins.set(name, plugin)\n    this.logger.info(`Registered plugin: ${name}@${plugin.metadata.version}`)\n    \n    this.emit('plugin:registered', plugin)\n  }\n  \n  /**\n   * Load plugin from path or module name\n   */\n  async loadPlugin(pluginId: string): Promise<void> {\n    if (this.loadedPlugins.has(pluginId)) {\n      return\n    }\n    \n    this.logger.info(`Loading plugin: ${pluginId}`)\n    \n    try {\n      let pluginModule: any\n      \n      // Try to require the plugin\n      if (pluginId.startsWith('.') || pluginId.startsWith('/')) {\n        // Local path\n        const pluginPath = resolve(pluginId)\n        if (!existsSync(pluginPath)) {\n          throw new Error(`Plugin file not found: ${pluginPath}`)\n        }\n        pluginModule = await import(pluginPath)\n      } else {\n        // Node module\n        try {\n          pluginModule = require(pluginId)\n        } catch {\n          // Try with plugin prefix\n          pluginModule = require(this.options.pluginPrefix + pluginId)\n        }\n      }\n      \n      // Extract plugin definition\n      const plugin = pluginModule.default || pluginModule\n      \n      if (typeof plugin === 'function') {\n        // Plugin factory function\n        const context = this.createPluginContext({ metadata: { name: pluginId, version: '1.0.0' } } as Plugin)\n        const pluginDef = await plugin(context)\n        \n        this.registerPlugin({\n          metadata: { name: pluginId, version: '1.0.0' },\n          options: {},\n          hooks: pluginDef,\n          factory: plugin\n        })\n      } else if (plugin.prototype && typeof plugin === 'function') {\n        // Plugin class\n        this.registerPlugin({\n          metadata: { name: pluginId, version: '1.0.0' },\n          options: {},\n          hooks: {},\n          PluginClass: plugin\n        })\n      } else {\n        // Direct plugin object\n        this.registerPlugin(plugin)\n      }\n      \n      this.loadedPlugins.add(pluginId)\n      this.emit('plugin:loaded', pluginId)\n      \n    } catch (error) {\n      this.logger.error(`Failed to load plugin ${pluginId}`, error as Error)\n      throw error\n    }\n  }\n  \n  /**\n   * Auto-discover plugins in search paths\n   */\n  async discoverPlugins(): Promise<void> {\n    this.logger.info('Discovering plugins...')\n    \n    const discovered: string[] = []\n    \n    for (const searchPath of this.options.searchPaths) {\n      try {\n        const path = resolve(searchPath)\n        \n        if (searchPath.includes('node_modules')) {\n          // Search for npm packages with plugin prefix\n          const packages = await this.utils.glob(`${this.options.pluginPrefix}*`, path)\n          discovered.push(...packages.map(pkg => pkg.replace(path + '/', '')))\n        } else {\n          // Search for local plugin files\n          const files = await this.utils.glob('**/*.{js,ts,mjs}', path)\n          discovered.push(...files.map(file => resolve(path, file)))\n        }\n      } catch (error) {\n        this.logger.warn(`Failed to discover plugins in ${searchPath}:`, error)\n      }\n    }\n    \n    this.logger.info(`Discovered ${discovered.length} potential plugins`)\n    \n    // Load discovered plugins\n    for (const plugin of discovered) {\n      try {\n        await this.loadPlugin(plugin)\n      } catch (error) {\n        this.logger.warn(`Failed to load discovered plugin ${plugin}:`, error)\n      }\n    }\n  }\n  \n  /**\n   * Load all registered plugins\n   */\n  async loadAllPlugins(): Promise<void> {\n    const sortedPlugins = Array.from(this.plugins.values())\n      .sort((a, b) => (b.options.priority || 0) - (a.options.priority || 0))\n    \n    for (const plugin of sortedPlugins) {\n      if (!plugin.options.enabled) {\n        continue\n      }\n      \n      await this.instantiatePlugin(plugin)\n    }\n  }\n  \n  /**\n   * Instantiate plugin and create context\n   */\n  async instantiatePlugin(plugin: Plugin): Promise<void> {\n    const name = plugin.metadata.name\n    \n    try {\n      // Create plugin context\n      plugin.context = this.createPluginContext(plugin)\n      \n      // Instantiate plugin based on type\n      if (plugin.factory) {\n        plugin.hooks = await plugin.factory(plugin.context)\n      } else if (plugin.PluginClass) {\n        plugin.instance = new plugin.PluginClass(plugin.context)\n        plugin.hooks = plugin.instance\n      }\n      \n      // Execute setup hook if available\n      if (plugin.setup) {\n        await plugin.setup(plugin.context)\n      }\n      \n      this.logger.info(`Instantiated plugin: ${name}`)\n      this.emit('plugin:instantiated', plugin)\n      \n    } catch (error) {\n      this.logger.error(`Failed to instantiate plugin ${name}`, error as Error)\n      throw error\n    }\n  }\n  \n  /**\n   * Execute a hook across all plugins\n   */\n  async executeHook(hookName: string, ...args: any[]): Promise<any[]> {\n    const results: any[] = []\n    const enabledPlugins = Array.from(this.plugins.values())\n      .filter(plugin => plugin.options.enabled && plugin.hooks[hookName])\n      .sort((a, b) => (b.options.priority || 0) - (a.options.priority || 0))\n    \n    this.logger.debug(`Executing hook: ${hookName} (${enabledPlugins.length} plugins)`)\n    \n    for (const plugin of enabledPlugins) {\n      try {\n        const hook = plugin.hooks[hookName]\n        if (hook && plugin.context) {\n          const result = await this.executeWithTimeout(\n            () => hook(plugin.context!, ...args),\n            this.options.hookTimeout,\n            `Hook ${hookName} in plugin ${plugin.metadata.name}`\n          )\n          \n          results.push(result)\n          \n          this.emit('hook:executed', {\n            plugin: plugin.metadata.name,\n            hook: hookName,\n            result\n          })\n        }\n      } catch (error) {\n        this.logger.error(\n          `Hook ${hookName} failed in plugin ${plugin.metadata.name}`,\n          error as Error\n        )\n        \n        this.emit('hook:error', {\n          plugin: plugin.metadata.name,\n          hook: hookName,\n          error\n        })\n        \n        // Continue with other plugins unless it's a critical hook\n        if (hookName.startsWith('system:')) {\n          throw error\n        }\n      }\n    }\n    \n    return results\n  }\n  \n  /**\n   * Get plugin by name\n   */\n  getPlugin(name: string): Plugin | undefined {\n    return this.plugins.get(name)\n  }\n  \n  /**\n   * Get all plugins\n   */\n  getAllPlugins(): Plugin[] {\n    return Array.from(this.plugins.values())\n  }\n  \n  /**\n   * Get enabled plugins\n   */\n  getEnabledPlugins(): Plugin[] {\n    return this.getAllPlugins().filter(plugin => plugin.options.enabled)\n  }\n  \n  /**\n   * Enable/disable plugin\n   */\n  setPluginEnabled(name: string, enabled: boolean): void {\n    const plugin = this.plugins.get(name)\n    if (plugin) {\n      plugin.options.enabled = enabled\n      this.emit('plugin:toggled', { name, enabled })\n    }\n  }\n  \n  /**\n   * Register service for dependency injection\n   */\n  registerService(name: string, service: any): void {\n    this.services.set(name, service)\n    this.logger.info(`Registered service: ${name}`)\n  }\n  \n  /**\n   * Get registered service\n   */\n  getService<T = any>(name: string): T | undefined {\n    return this.services.get(name)\n  }\n  \n  /**\n   * Destroy plugin manager and cleanup\n   */\n  async destroy(): Promise<void> {\n    this.logger.info('Destroying plugin manager...')\n    \n    try {\n      // Execute system:destroy hooks\n      await this.executeHook('system:destroy')\n      \n      // Execute teardown for each plugin\n      for (const plugin of this.plugins.values()) {\n        if (plugin.teardown && plugin.context) {\n          try {\n            await plugin.teardown(plugin.context)\n          } catch (error) {\n            this.logger.error(\n              `Teardown failed for plugin ${plugin.metadata.name}`,\n              error as Error\n            )\n          }\n        }\n      }\n      \n      // Clear state\n      this.plugins.clear()\n      this.loadedPlugins.clear()\n      this.services.clear()\n      this.cache.clear()\n      \n      this.emit('destroyed')\n      this.removeAllListeners()\n      \n    } catch (error) {\n      this.logger.error('Failed to destroy plugin manager', error as Error)\n      throw error\n    }\n  }\n  \n  private createPluginContext(plugin: Plugin): PluginContext {\n    return {\n      plugin,\n      manager: this,\n      config: defu(plugin.options.config, this.options.globalConfig),\n      logger: this.createPluginLogger(plugin.metadata.name),\n      cache: new MemoryCache(),\n      utils: this.utils,\n      services: this.services\n    }\n  }\n  \n  private createLogger(): PluginLogger {\n    return {\n      debug: (message: string, ...args: any[]) => {\n        if (this.options.development) {\n          console.debug(`[unjucks:plugin] ${message}`, ...args)\n        }\n      },\n      info: (message: string, ...args: any[]) => {\n        console.log(`[unjucks:plugin] ${message}`, ...args)\n      },\n      warn: (message: string, ...args: any[]) => {\n        console.warn(`[unjucks:plugin] ${message}`, ...args)\n      },\n      error: (message: string, error?: Error, ...args: any[]) => {\n        console.error(`[unjucks:plugin] ${message}`, error, ...args)\n      }\n    }\n  }\n  \n  private createPluginLogger(pluginName: string): PluginLogger {\n    return {\n      debug: (message: string, ...args: any[]) => {\n        if (this.options.development) {\n          console.debug(`[unjucks:plugin:${pluginName}] ${message}`, ...args)\n        }\n      },\n      info: (message: string, ...args: any[]) => {\n        console.log(`[unjucks:plugin:${pluginName}] ${message}`, ...args)\n      },\n      warn: (message: string, ...args: any[]) => {\n        console.warn(`[unjucks:plugin:${pluginName}] ${message}`, ...args)\n      },\n      error: (message: string, error?: Error, ...args: any[]) => {\n        console.error(`[unjucks:plugin:${pluginName}] ${message}`, error, ...args)\n      }\n    }\n  }\n  \n  private createUtils(): PluginUtils {\n    return {\n      resolve: (path: string) => resolve(path),\n      \n      requireModule: (id: string) => require(id),\n      \n      loadJson: async (path: string) => {\n        const content = await readFile(resolve(path), 'utf-8')\n        return JSON.parse(content)\n      },\n      \n      writeJson: async (path: string, data: any) => {\n        const { writeFile, mkdir } = await import('node:fs/promises')\n        await mkdir(dirname(path), { recursive: true })\n        await writeFile(path, JSON.stringify(data, null, 2))\n      },\n      \n      glob: async (pattern: string, cwd?: string) => {\n        const { glob } = await import('fast-glob')\n        return glob(pattern, { cwd: cwd || process.cwd() })\n      },\n      \n      isFile: async (path: string) => {\n        const { stat } = await import('node:fs/promises')\n        try {\n          const stats = await stat(resolve(path))\n          return stats.isFile()\n        } catch {\n          return false\n        }\n      },\n      \n      isDirectory: async (path: string) => {\n        const { stat } = await import('node:fs/promises')\n        try {\n          const stats = await stat(resolve(path))\n          return stats.isDirectory()\n        } catch {\n          return false\n        }\n      }\n    }\n  }\n  \n  private validatePlugin(plugin: Plugin): void {\n    if (!plugin.metadata?.name) {\n      throw new Error('Plugin metadata.name is required')\n    }\n    \n    if (!plugin.metadata.version) {\n      throw new Error('Plugin metadata.version is required')\n    }\n    \n    if (!plugin.hooks && !plugin.factory && !plugin.PluginClass) {\n      throw new Error('Plugin must have hooks, factory, or PluginClass')\n    }\n  }\n  \n  private setupErrorHandling(): void {\n    process.on('uncaughtException', (error) => {\n      this.logger.error('Uncaught exception in plugin system', error)\n    })\n    \n    process.on('unhandledRejection', (reason) => {\n      this.logger.error('Unhandled rejection in plugin system', reason as Error)\n    })\n  }\n  \n  private async executeWithTimeout<T>(\n    fn: () => Promise<T> | T,\n    timeout: number,\n    context: string\n  ): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Timeout: ${context} took longer than ${timeout}ms`))\n      }, timeout)\n      \n      Promise.resolve(fn())\n        .then(result => {\n          clearTimeout(timer)\n          resolve(result)\n        })\n        .catch(error => {\n          clearTimeout(timer)\n          reject(error)\n        })\n    })\n  }\n}\n\n/**\n * Helper function to create plugin definition\n */\nexport function definePlugin(\n  metadata: PluginMetadata,\n  hooks: PluginHooks,\n  options: PluginOptions = {}\n): Plugin {\n  return {\n    metadata,\n    hooks,\n    options\n  }\n}\n\n/**\n * Helper function to create plugin factory\n */\nexport function definePluginFactory(\n  metadata: PluginMetadata,\n  factory: (context: PluginContext) => PluginHooks | Promise<PluginHooks>,\n  options: PluginOptions = {}\n): Plugin {\n  return {\n    metadata,\n    hooks: {},\n    factory,\n    options\n  }\n}\n\n/**\n * Helper function to create plugin class\n */\nexport function definePluginClass(\n  metadata: PluginMetadata,\n  PluginClass: new (context: PluginContext) => PluginHooks,\n  options: PluginOptions = {}\n): Plugin {\n  return {\n    metadata,\n    hooks: {},\n    PluginClass,\n    options\n  }\n}\n\n/**\n * Global plugin manager instance\n */\nlet globalPluginManager: PluginManager | null = null\n\n/**\n * Get or create global plugin manager\n */\nexport function getPluginManager(options?: PluginManagerOptions): PluginManager {\n  if (!globalPluginManager) {\n    globalPluginManager = new PluginManager(options)\n  }\n  return globalPluginManager\n}\n\n/**\n * Initialize global plugin manager\n */\nexport async function initializePlugins(options?: PluginManagerOptions): Promise<PluginManager> {\n  const manager = getPluginManager(options)\n  if (!manager.listenerCount('initialized')) {\n    await manager.initialize()\n  }\n  return manager\n}\n\n/**\n * Execute hook on global plugin manager\n */\nexport async function executePluginHook(hookName: string, ...args: any[]): Promise<any[]> {\n  const manager = getPluginManager()\n  return manager.executeHook(hookName, ...args)\n}\n\n/**\n * Register plugin on global manager\n */\nexport function registerPlugin(plugin: Plugin): void {\n  const manager = getPluginManager()\n  manager.registerPlugin(plugin)\n}\n\nexport {\n  PluginManager,\n  type Plugin,\n  type PluginHooks,\n  type PluginContext,\n  type PluginMetadata,\n  type PluginOptions,\n  type PluginManagerOptions\n}"