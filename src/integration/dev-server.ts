/**\n * üöÄ Development Server: Live Template Development Environment\n * Hot reload, live preview, debugging tools, and development workflow\n * Integrated WebSocket communication and file watching\n */\n\nimport { createServer, type IncomingMessage, type ServerResponse } from 'node:http'\nimport { WebSocketServer, WebSocket } from 'ws'\nimport { resolve, join, relative, extname } from 'pathe'\nimport { readFile, stat, access } from 'node:fs/promises'\nimport { existsSync } from 'node:fs'\nimport { parse } from 'node:url'\nimport { defu } from 'defu'\nimport { UNJUCKS } from '../unjucks'\nimport { loadGraph, toContext } from '../untology'\nimport { createTemplateContext } from '../context'\nimport { MemoryCache } from '../cache'\n\nexport interface DevServerOptions {\n  /**\n   * Server port\n   * @default 3000\n   */\n  port?: number\n  \n  /**\n   * Server host\n   * @default 'localhost'\n   */\n  host?: string\n  \n  /**\n   * Templates directory\n   * @default './templates'\n   */\n  templatesDir?: string\n  \n  /**\n   * Ontology directory\n   * @default './ontology'\n   */\n  ontologyDir?: string\n  \n  /**\n   * Static assets directory\n   * @default './public'\n   */\n  publicDir?: string\n  \n  /**\n   * Enable hot reload\n   * @default true\n   */\n  hotReload?: boolean\n  \n  /**\n   * Enable template preview UI\n   * @default true\n   */\n  previewUI?: boolean\n  \n  /**\n   * Enable debugging tools\n   * @default true\n   */\n  debugTools?: boolean\n  \n  /**\n   * Auto-open browser\n   * @default true\n   */\n  open?: boolean\n  \n  /**\n   * Global context for templates\n   */\n  globalContext?: Record<string, any>\n  \n  /**\n   * Custom middleware\n   */\n  middleware?: Array<(req: IncomingMessage, res: ServerResponse, next: () => void) => void>\n  \n  /**\n   * CORS configuration\n   */\n  cors?: {\n    enabled?: boolean\n    origin?: string | string[]\n    methods?: string[]\n    headers?: string[]\n  }\n  \n  /**\n   * WebSocket configuration\n   */\n  websocket?: {\n    enabled?: boolean\n    port?: number\n  }\n}\n\ninterface ClientConnection {\n  id: string\n  ws: WebSocket\n  subscriptions: Set<string>\n  lastActivity: number\n}\n\ninterface DevServerMessage {\n  type: 'reload' | 'update' | 'error' | 'log' | 'template-change' | 'ontology-change'\n  data?: any\n  timestamp: number\n}\n\nconst DEFAULT_OPTIONS: Required<DevServerOptions> = {\n  port: 3000,\n  host: 'localhost',\n  templatesDir: './templates',\n  ontologyDir: './ontology',\n  publicDir: './public',\n  hotReload: true,\n  previewUI: true,\n  debugTools: true,\n  open: true,\n  globalContext: {},\n  middleware: [],\n  cors: {\n    enabled: true,\n    origin: '*',\n    methods: ['GET', 'POST', 'OPTIONS'],\n    headers: ['content-type', 'x-template-id', 'x-context']\n  },\n  websocket: {\n    enabled: true,\n    port: 3001\n  }\n}\n\nexport class UnjucksDevServer {\n  private options: Required<DevServerOptions>\n  private server: ReturnType<typeof createServer> | null = null\n  private wsServer: WebSocketServer | null = null\n  private clients = new Map<string, ClientConnection>()\n  private watcher: any = null\n  private templateContext: any = null\n  private cache = new MemoryCache<any>()\n  private ontologyLoaded = false\n  \n  constructor(options: DevServerOptions = {}) {\n    this.options = defu(options, DEFAULT_OPTIONS)\n  }\n  \n  /**\n   * Start the development server\n   */\n  async start(): Promise<void> {\n    console.log('üöÄ Starting Unjucks development server...')\n    \n    try {\n      // Initialize template system\n      await this.initialize()\n      \n      // Create HTTP server\n      this.server = createServer(this.handleRequest.bind(this))\n      \n      // Setup WebSocket server\n      if (this.options.websocket.enabled) {\n        await this.setupWebSocket()\n      }\n      \n      // Setup file watching\n      if (this.options.hotReload) {\n        this.setupFileWatcher()\n      }\n      \n      // Start listening\n      await new Promise<void>((resolve) => {\n        this.server!.listen(this.options.port, this.options.host, () => {\n          const url = `http://${this.options.host}:${this.options.port}`\n          console.log(`üåê Server running at ${url}`)\n          \n          if (this.options.previewUI) {\n            console.log(`üìã Preview UI available at ${url}/unjucks`)\n          }\n          \n          if (this.options.open) {\n            this.openBrowser(url)\n          }\n          \n          resolve()\n        })\n      })\n      \n    } catch (error) {\n      console.error('‚ùå Failed to start development server:', error)\n      throw error\n    }\n  }\n  \n  /**\n   * Stop the development server\n   */\n  async stop(): Promise<void> {\n    console.log('üõë Stopping development server...')\n    \n    // Close file watcher\n    if (this.watcher) {\n      this.watcher.close()\n    }\n    \n    // Close WebSocket connections\n    for (const client of this.clients.values()) {\n      client.ws.close()\n    }\n    this.clients.clear()\n    \n    // Close WebSocket server\n    if (this.wsServer) {\n      this.wsServer.close()\n    }\n    \n    // Close HTTP server\n    if (this.server) {\n      await new Promise<void>((resolve) => {\n        this.server!.close(() => resolve())\n      })\n    }\n    \n    console.log('‚úÖ Development server stopped')\n  }\n  \n  private async initialize(): Promise<void> {\n    // Initialize template context\n    this.templateContext = await createTemplateContext({\n      templatesDir: this.options.templatesDir,\n      outputDir: join(process.cwd(), '.unjucks-dev'),\n      cache: false // Disable cache in development\n    })\n    \n    // Load ontologies\n    await this.loadOntologies()\n    \n    console.log('‚úÖ Template system initialized')\n  }\n  \n  private async loadOntologies(): Promise<void> {\n    if (!existsSync(this.options.ontologyDir)) {\n      console.warn(`‚ö†Ô∏è  Ontology directory not found: ${this.options.ontologyDir}`)\n      return\n    }\n    \n    try {\n      const { glob } = await import('fast-glob')\n      const ontologyFiles = await glob(['**/*.ttl', '**/*.jsonld', '**/*.n3'], {\n        cwd: this.options.ontologyDir,\n        onlyFiles: true\n      })\n      \n      for (const file of ontologyFiles) {\n        const ontologyPath = join(this.options.ontologyDir, file)\n        await loadGraph(ontologyPath)\n      }\n      \n      this.ontologyLoaded = ontologyFiles.length > 0\n      \n      if (this.ontologyLoaded) {\n        console.log(`üìö Loaded ${ontologyFiles.length} ontology files`)\n      }\n    } catch (error) {\n      console.error('‚ùå Failed to load ontologies:', error)\n    }\n  }\n  \n  private async handleRequest(req: IncomingMessage, res: ServerResponse): Promise<void> {\n    const url = parse(req.url || '/', true)\n    const pathname = url.pathname || '/'\n    \n    try {\n      // Apply CORS headers\n      if (this.options.cors.enabled) {\n        this.setCorsHeaders(res)\n        \n        if (req.method === 'OPTIONS') {\n          res.statusCode = 200\n          res.end()\n          return\n        }\n      }\n      \n      // Apply custom middleware\n      let middlewareIndex = 0\n      const runMiddleware = () => {\n        if (middlewareIndex < this.options.middleware.length) {\n          const middleware = this.options.middleware[middlewareIndex++]\n          middleware(req, res, runMiddleware)\n        } else {\n          this.routeRequest(req, res, pathname, url.query || {})\n        }\n      }\n      \n      runMiddleware()\n      \n    } catch (error) {\n      console.error('‚ùå Request handling error:', error)\n      this.sendError(res, 500, 'Internal Server Error', error)\n    }\n  }\n  \n  private async routeRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: Record<string, any>\n  ): Promise<void> {\n    // Template rendering endpoints\n    if (pathname.startsWith('/api/template')) {\n      await this.handleTemplateApi(req, res, pathname, query)\n      return\n    }\n    \n    // Preview UI\n    if (pathname === '/unjucks' || pathname.startsWith('/unjucks/')) {\n      await this.handlePreviewUI(req, res, pathname)\n      return\n    }\n    \n    // Debug tools\n    if (pathname.startsWith('/debug/')) {\n      await this.handleDebugTools(req, res, pathname)\n      return\n    }\n    \n    // Static assets\n    if (pathname.startsWith('/static/')) {\n      await this.handleStaticAssets(req, res, pathname)\n      return\n    }\n    \n    // Default response\n    if (pathname === '/') {\n      this.sendResponse(res, 200, 'text/html', this.generateWelcomePage())\n    } else {\n      this.sendError(res, 404, 'Not Found')\n    }\n  }\n  \n  private async handleTemplateApi(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: Record<string, any>\n  ): Promise<void> {\n    const parts = pathname.split('/').filter(Boolean)\n    \n    if (parts[2] === 'render') {\n      // Template rendering: /api/template/render\n      await this.handleTemplateRender(req, res, query)\n    } else if (parts[2] === 'list') {\n      // Template listing: /api/template/list\n      await this.handleTemplateList(req, res)\n    } else if (parts[2] === 'context') {\n      // Context info: /api/template/context\n      await this.handleContextInfo(req, res)\n    } else {\n      this.sendError(res, 404, 'API endpoint not found')\n    }\n  }\n  \n  private async handleTemplateRender(\n    req: IncomingMessage,\n    res: ServerResponse,\n    query: Record<string, any>\n  ): Promise<void> {\n    const templateId = query.template as string\n    const contextParam = query.context as string\n    const format = (query.format as string) || 'html'\n    \n    if (!templateId) {\n      this.sendError(res, 400, 'Template ID is required')\n      return\n    }\n    \n    try {\n      // Parse context\n      let customContext = {}\n      if (contextParam) {\n        try {\n          customContext = JSON.parse(decodeURIComponent(contextParam))\n        } catch {\n          customContext = { raw: contextParam }\n        }\n      }\n      \n      // Merge contexts\n      const context = {\n        ...this.options.globalContext,\n        ...customContext,\n        ...(this.ontologyLoaded ? toContext() : {}),\n        $dev: {\n          mode: 'development',\n          hotReload: this.options.hotReload,\n          timestamp: new Date().toISOString()\n        }\n      }\n      \n      // Generate template\n      const result = await UNJUCKS.generateFromOntology(\n        this.options.ontologyDir,\n        templateId,\n        { context }\n      )\n      \n      if (result.success && result.files.length > 0) {\n        const output = result.files[0].content\n        \n        // Set response headers\n        res.setHeader('x-template-id', templateId)\n        res.setHeader('x-generation-time', `${result.duration}ms`)\n        \n        if (format === 'json') {\n          this.sendResponse(res, 200, 'application/json', JSON.stringify({\n            templateId,\n            content: output,\n            metadata: {\n              duration: result.duration,\n              files: result.files.length\n            }\n          }, null, 2))\n        } else {\n          // Inject hot reload script if enabled\n          let finalOutput = output\n          if (this.options.hotReload && output.includes('</body>')) {\n            finalOutput = output.replace('</body>', this.getHotReloadScript() + '</body>')\n          }\n          \n          this.sendResponse(res, 200, 'text/html', finalOutput)\n        }\n      } else {\n        this.sendError(res, 500, 'Template generation failed', result.errors?.[0])\n      }\n    } catch (error) {\n      this.sendError(res, 500, 'Template rendering error', error)\n    }\n  }\n  \n  private async handleTemplateList(req: IncomingMessage, res: ServerResponse): Promise<void> {\n    try {\n      const { glob } = await import('fast-glob')\n      const templateFiles = await glob(['**/*.{njk,nunjucks,j2}'], {\n        cwd: this.options.templatesDir,\n        onlyFiles: true\n      })\n      \n      const templates = templateFiles.map(file => ({\n        id: file.replace(/\\.[^.]+$/, '').replace(/[^a-zA-Z0-9]/g, '-'),\n        name: file,\n        path: join(this.options.templatesDir, file)\n      }))\n      \n      this.sendResponse(res, 200, 'application/json', JSON.stringify({\n        templates,\n        count: templates.length\n      }, null, 2))\n    } catch (error) {\n      this.sendError(res, 500, 'Failed to list templates', error)\n    }\n  }\n  \n  private async handleContextInfo(req: IncomingMessage, res: ServerResponse): Promise<void> {\n    const context = {\n      global: this.options.globalContext,\n      ontology: this.ontologyLoaded ? toContext() : null,\n      system: {\n        templatesDir: this.options.templatesDir,\n        ontologyDir: this.options.ontologyDir,\n        hotReload: this.options.hotReload,\n        clients: this.clients.size\n      }\n    }\n    \n    this.sendResponse(res, 200, 'application/json', JSON.stringify(context, null, 2))\n  }\n  \n  private async handlePreviewUI(req: IncomingMessage, res: ServerResponse, pathname: string): Promise<void> {\n    if (pathname === '/unjucks' || pathname === '/unjucks/') {\n      this.sendResponse(res, 200, 'text/html', this.generatePreviewUI())\n    } else {\n      this.sendError(res, 404, 'Preview UI resource not found')\n    }\n  }\n  \n  private async handleDebugTools(req: IncomingMessage, res: ServerResponse, pathname: string): Promise<void> {\n    if (!this.options.debugTools) {\n      this.sendError(res, 403, 'Debug tools disabled')\n      return\n    }\n    \n    // Implementation for debug tools would go here\n    this.sendResponse(res, 200, 'application/json', JSON.stringify({\n      message: 'Debug tools not implemented yet',\n      path: pathname\n    }))\n  }\n  \n  private async handleStaticAssets(req: IncomingMessage, res: ServerResponse, pathname: string): Promise<void> {\n    const filePath = join(this.options.publicDir, pathname.replace('/static/', ''))\n    \n    try {\n      await access(filePath)\n      const content = await readFile(filePath)\n      const contentType = this.getContentType(filePath)\n      \n      res.setHeader('content-type', contentType)\n      res.statusCode = 200\n      res.end(content)\n    } catch {\n      this.sendError(res, 404, 'Static asset not found')\n    }\n  }\n  \n  private setupWebSocket(): Promise<void> {\n    return new Promise((resolve) => {\n      this.wsServer = new WebSocketServer({\n        port: this.options.websocket.port,\n        host: this.options.host\n      })\n      \n      this.wsServer.on('connection', (ws: WebSocket) => {\n        const clientId = this.generateClientId()\n        \n        const client: ClientConnection = {\n          id: clientId,\n          ws,\n          subscriptions: new Set(),\n          lastActivity: Date.now()\n        }\n        \n        this.clients.set(clientId, client)\n        \n        ws.on('message', (data: Buffer) => {\n          try {\n            const message = JSON.parse(data.toString())\n            this.handleWebSocketMessage(client, message)\n          } catch (error) {\n            console.error('WebSocket message parsing error:', error)\n          }\n        })\n        \n        ws.on('close', () => {\n          this.clients.delete(clientId)\n        })\n        \n        // Send welcome message\n        this.sendWebSocketMessage(client, {\n          type: 'log',\n          data: { message: 'Connected to Unjucks dev server' },\n          timestamp: Date.now()\n        })\n      })\n      \n      this.wsServer.on('listening', () => {\n        console.log(`üîå WebSocket server running on ws://${this.options.host}:${this.options.websocket.port}`)\n        resolve()\n      })\n    })\n  }\n  \n  private handleWebSocketMessage(client: ClientConnection, message: any): void {\n    client.lastActivity = Date.now()\n    \n    switch (message.type) {\n      case 'subscribe':\n        if (message.data?.channel) {\n          client.subscriptions.add(message.data.channel)\n        }\n        break\n        \n      case 'unsubscribe':\n        if (message.data?.channel) {\n          client.subscriptions.delete(message.data.channel)\n        }\n        break\n        \n      case 'ping':\n        this.sendWebSocketMessage(client, {\n          type: 'pong',\n          timestamp: Date.now()\n        })\n        break\n    }\n  }\n  \n  private setupFileWatcher(): void {\n    const chokidar = require('chokidar')\n    \n    const watchPaths = [\n      join(this.options.templatesDir, '**/*'),\n      join(this.options.ontologyDir, '**/*')\n    ]\n    \n    this.watcher = chokidar.watch(watchPaths, {\n      ignored: /node_modules/,\n      ignoreInitial: true,\n      persistent: true\n    })\n    \n    this.watcher.on('change', async (filePath: string) => {\n      console.log(`üìù File changed: ${relative(process.cwd(), filePath)}`)\n      \n      // Clear cache\n      this.cache.clear()\n      \n      // Reload ontologies if needed\n      if (filePath.includes(this.options.ontologyDir)) {\n        await this.loadOntologies()\n        this.broadcastWebSocketMessage({\n          type: 'ontology-change',\n          data: { filePath },\n          timestamp: Date.now()\n        })\n      } else {\n        this.broadcastWebSocketMessage({\n          type: 'template-change',\n          data: { filePath },\n          timestamp: Date.now()\n        })\n      }\n      \n      // Trigger hot reload\n      this.broadcastWebSocketMessage({\n        type: 'reload',\n        timestamp: Date.now()\n      })\n    })\n    \n    console.log('üëÄ File watcher active')\n  }\n  \n  private sendWebSocketMessage(client: ClientConnection, message: DevServerMessage): void {\n    if (client.ws.readyState === WebSocket.OPEN) {\n      client.ws.send(JSON.stringify(message))\n    }\n  }\n  \n  private broadcastWebSocketMessage(message: DevServerMessage, channel?: string): void {\n    for (const client of this.clients.values()) {\n      if (!channel || client.subscriptions.has(channel)) {\n        this.sendWebSocketMessage(client, message)\n      }\n    }\n  }\n  \n  private setCorsHeaders(res: ServerResponse): void {\n    const { cors } = this.options\n    \n    res.setHeader('access-control-allow-origin', \n      Array.isArray(cors.origin) ? cors.origin.join(',') : cors.origin || '*')\n    res.setHeader('access-control-allow-methods', cors.methods?.join(',') || 'GET,POST,OPTIONS')\n    res.setHeader('access-control-allow-headers', cors.headers?.join(',') || 'content-type')\n  }\n  \n  private sendResponse(res: ServerResponse, status: number, contentType: string, content: string): void {\n    res.statusCode = status\n    res.setHeader('content-type', contentType)\n    res.end(content)\n  }\n  \n  private sendError(res: ServerResponse, status: number, message: string, error?: any): void {\n    const errorResponse = {\n      error: message,\n      status,\n      details: error && process.env.NODE_ENV === 'development' ? error.message : undefined\n    }\n    \n    this.sendResponse(res, status, 'application/json', JSON.stringify(errorResponse, null, 2))\n  }\n  \n  private getContentType(filePath: string): string {\n    const ext = extname(filePath).toLowerCase()\n    const mimeTypes: Record<string, string> = {\n      '.html': 'text/html',\n      '.css': 'text/css',\n      '.js': 'application/javascript',\n      '.json': 'application/json',\n      '.png': 'image/png',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.gif': 'image/gif',\n      '.svg': 'image/svg+xml',\n      '.ico': 'image/x-icon'\n    }\n    \n    return mimeTypes[ext] || 'application/octet-stream'\n  }\n  \n  private generateClientId(): string {\n    return Math.random().toString(36).substring(2) + Date.now().toString(36)\n  }\n  \n  private generateWelcomePage(): string {\n    return `\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Unjucks Development Server</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }\n    .container { max-width: 800px; margin: 0 auto; }\n    h1 { font-size: 3em; margin-bottom: 20px; }\n    .subtitle { font-size: 1.2em; opacity: 0.8; margin-bottom: 40px; }\n    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }\n    .card { background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 20px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); }\n    .card h3 { margin-top: 0; }\n    .card a { color: white; text-decoration: none; }\n    .card a:hover { text-decoration: underline; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>üöÄ Unjucks Dev Server</h1>\n    <p class=\"subtitle\">Universal template system with ontology-driven context management</p>\n    \n    <div class=\"cards\">\n      <div class=\"card\">\n        <h3>üìã Preview UI</h3>\n        <p>Interactive template testing and preview interface</p>\n        <a href=\"/unjucks\">Open Preview UI ‚Üí</a>\n      </div>\n      \n      <div class=\"card\">\n        <h3>üîß API Endpoints</h3>\n        <p>Template rendering and management API</p>\n        <a href=\"/api/template/list\">List Templates ‚Üí</a>\n      </div>\n      \n      <div class=\"card\">\n        <h3>üìö Context Info</h3>\n        <p>View available template context and ontology data</p>\n        <a href=\"/api/template/context\">View Context ‚Üí</a>\n      </div>\n      \n      <div class=\"card\">\n        <h3>üîå WebSocket</h3>\n        <p>Live updates and hot reload connections</p>\n        <code>ws://${this.options.host}:${this.options.websocket.port}</code>\n      </div>\n    </div>\n    \n    <div style=\"margin-top: 40px; text-align: center; opacity: 0.6;\">\n      <p>Server running on port ${this.options.port} | Hot reload ${this.options.hotReload ? 'enabled' : 'disabled'}</p>\n    </div>\n  </div>\n</body>\n</html>`\n  }\n  \n  private generatePreviewUI(): string {\n    return `\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Unjucks Template Preview</title>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <style>\n    * { box-sizing: border-box; }\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background: #f5f5f5; }\n    .header { background: white; border-bottom: 1px solid #eee; padding: 20px; }\n    .header h1 { margin: 0; color: #333; }\n    .container { display: flex; height: calc(100vh - 80px); }\n    .sidebar { width: 300px; background: white; border-right: 1px solid #eee; overflow-y: auto; }\n    .main { flex: 1; display: flex; flex-direction: column; }\n    .controls { background: white; border-bottom: 1px solid #eee; padding: 20px; }\n    .preview { flex: 1; background: white; position: relative; }\n    .form-group { margin-bottom: 15px; }\n    .form-group label { display: block; margin-bottom: 5px; font-weight: 500; color: #333; }\n    .form-group input, .form-group textarea, .form-group select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; }\n    .form-group textarea { height: 100px; resize: vertical; font-family: 'Monaco', 'Menlo', monospace; font-size: 12px; }\n    .btn { background: #007acc; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }\n    .btn:hover { background: #005a99; }\n    .btn-secondary { background: #6c757d; }\n    .btn-secondary:hover { background: #545b62; }\n    iframe { width: 100%; height: 100%; border: none; }\n    .templates-list { padding: 20px; }\n    .template-item { padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; }\n    .template-item:hover { background: #f5f5f5; }\n    .template-item.active { background: #e3f2fd; }\n    .status { padding: 10px; background: #f8f9fa; border-top: 1px solid #eee; font-size: 12px; color: #666; }\n    .error { background: #f8d7da; color: #721c24; padding: 15px; margin: 10px; border-radius: 4px; }\n    .loading { text-align: center; padding: 40px; color: #666; }\n  </style>\n</head>\n<body>\n  <div class=\"header\">\n    <h1>üé® Unjucks Template Preview</h1>\n  </div>\n  \n  <div class=\"container\">\n    <div class=\"sidebar\">\n      <div class=\"templates-list\">\n        <h3>Templates</h3>\n        <div id=\"templatesList\">Loading...</div>\n      </div>\n    </div>\n    \n    <div class=\"main\">\n      <div class=\"controls\">\n        <div class=\"form-group\">\n          <label>Template ID</label>\n          <input type=\"text\" id=\"templateId\" placeholder=\"Enter template ID or select from list\">\n        </div>\n        \n        <div class=\"form-group\">\n          <label>Context (JSON)</label>\n          <textarea id=\"context\" placeholder='{\"key\": \"value\"}'></textarea>\n        </div>\n        \n        <div style=\"display: flex; align-items: center;\">\n          <button class=\"btn\" onclick=\"renderTemplate()\">Render Template</button>\n          <button class=\"btn btn-secondary\" onclick=\"clearPreview()\">Clear</button>\n          <label style=\"margin-left: auto;\"><input type=\"checkbox\" id=\"autoRender\"> Auto-render</label>\n        </div>\n      </div>\n      \n      <div class=\"preview\">\n        <iframe id=\"previewFrame\" src=\"about:blank\"></iframe>\n      </div>\n      \n      <div class=\"status\" id=\"status\">\n        Ready\n      </div>\n    </div>\n  </div>\n  \n  ${this.getHotReloadScript()}\n  \n  <script>\n    let templates = [];\n    let currentTemplate = null;\n    let autoRender = false;\n    \n    // Load templates list\n    async function loadTemplates() {\n      try {\n        const response = await fetch('/api/template/list');\n        const data = await response.json();\n        templates = data.templates;\n        renderTemplatesList();\n      } catch (error) {\n        console.error('Failed to load templates:', error);\n      }\n    }\n    \n    function renderTemplatesList() {\n      const list = document.getElementById('templatesList');\n      list.innerHTML = templates.map(template => \n        \\`<div class=\"template-item\" onclick=\"selectTemplate('\\${template.id}')\">\n          <strong>\\${template.name}</strong><br>\n          <small>\\${template.id}</small>\n        </div>\\`\n      ).join('');\n    }\n    \n    function selectTemplate(templateId) {\n      document.getElementById('templateId').value = templateId;\n      currentTemplate = templateId;\n      \n      // Update active state\n      document.querySelectorAll('.template-item').forEach(item => {\n        item.classList.remove('active');\n      });\n      event.target.closest('.template-item').classList.add('active');\n      \n      if (autoRender) {\n        renderTemplate();\n      }\n    }\n    \n    async function renderTemplate() {\n      const templateId = document.getElementById('templateId').value;\n      const contextText = document.getElementById('context').value || '{}';\n      \n      if (!templateId) {\n        updateStatus('Please select or enter a template ID', 'error');\n        return;\n      }\n      \n      updateStatus('Rendering template...', 'loading');\n      \n      try {\n        const params = new URLSearchParams({\n          template: templateId,\n          context: encodeURIComponent(contextText)\n        });\n        \n        const iframe = document.getElementById('previewFrame');\n        iframe.src = '/api/template/render?' + params.toString();\n        \n        iframe.onload = () => {\n          updateStatus(\\`Template rendered successfully - \\${templateId}\\`);\n        };\n        \n        iframe.onerror = () => {\n          updateStatus('Failed to render template', 'error');\n        };\n      } catch (error) {\n        updateStatus('Error: ' + error.message, 'error');\n      }\n    }\n    \n    function clearPreview() {\n      document.getElementById('previewFrame').src = 'about:blank';\n      updateStatus('Preview cleared');\n    }\n    \n    function updateStatus(message, type = 'info') {\n      const status = document.getElementById('status');\n      status.textContent = message;\n      status.className = 'status' + (type !== 'info' ? ' ' + type : '');\n    }\n    \n    // Auto-render toggle\n    document.getElementById('autoRender').addEventListener('change', (e) => {\n      autoRender = e.target.checked;\n    });\n    \n    // Context change handler for auto-render\n    document.getElementById('context').addEventListener('input', () => {\n      if (autoRender && currentTemplate) {\n        clearTimeout(window.renderTimeout);\n        window.renderTimeout = setTimeout(renderTemplate, 1000);\n      }\n    });\n    \n    // Initialize\n    loadTemplates();\n  </script>\n</body>\n</html>`\n  }\n  \n  private getHotReloadScript(): string {\n    if (!this.options.hotReload || !this.options.websocket.enabled) {\n      return ''\n    }\n    \n    return `\n<script>\n  (function() {\n    const ws = new WebSocket('ws://${this.options.host}:${this.options.websocket.port}');\n    \n    ws.onopen = function() {\n      console.log('[Unjucks] Connected to dev server');\n    };\n    \n    ws.onmessage = function(event) {\n      const message = JSON.parse(event.data);\n      \n      switch(message.type) {\n        case 'reload':\n          console.log('[Unjucks] Reloading page...');\n          window.location.reload();\n          break;\n          \n        case 'template-change':\n          console.log('[Unjucks] Template changed:', message.data.filePath);\n          if (typeof window.onTemplateChange === 'function') {\n            window.onTemplateChange(message.data);\n          } else {\n            window.location.reload();\n          }\n          break;\n          \n        case 'ontology-change':\n          console.log('[Unjucks] Ontology changed:', message.data.filePath);\n          if (typeof window.onOntologyChange === 'function') {\n            window.onOntologyChange(message.data);\n          } else {\n            window.location.reload();\n          }\n          break;\n          \n        case 'error':\n          console.error('[Unjucks] Server error:', message.data);\n          break;\n      }\n    };\n    \n    ws.onclose = function() {\n      console.log('[Unjucks] Disconnected from dev server');\n    };\n    \n    ws.onerror = function(error) {\n      console.error('[Unjucks] WebSocket error:', error);\n    };\n    \n    window.__UNJUCKS_WS__ = ws;\n  })();\n</script>`\n  }\n  \n  private async openBrowser(url: string): Promise<void> {\n    const open = (await import('open')).default\n    try {\n      await open(url)\n    } catch {\n      // Silently fail if browser can't be opened\n    }\n  }\n}\n\n/**\n * Create and start development server\n */\nexport async function startDevServer(options: DevServerOptions = {}): Promise<UnjucksDevServer> {\n  const server = new UnjucksDevServer(options)\n  await server.start()\n  return server\n}\n\n/**\n * CLI command for starting dev server\n */\nexport function createDevServerCommand() {\n  return {\n    meta: {\n      name: 'dev',\n      description: 'Start development server with hot reload and preview UI'\n    },\n    args: {\n      port: {\n        type: 'string',\n        description: 'Server port',\n        default: '3000'\n      },\n      host: {\n        type: 'string', \n        description: 'Server host',\n        default: 'localhost'\n      },\n      templates: {\n        type: 'string',\n        description: 'Templates directory',\n        default: './templates'\n      },\n      ontology: {\n        type: 'string',\n        description: 'Ontology directory', \n        default: './ontology'\n      },\n      'no-open': {\n        type: 'boolean',\n        description: 'Do not open browser'\n      },\n      'no-hot-reload': {\n        type: 'boolean',\n        description: 'Disable hot reload'\n      }\n    },\n    async run({ args }) {\n      const server = await startDevServer({\n        port: parseInt(args.port),\n        host: args.host,\n        templatesDir: args.templates,\n        ontologyDir: args.ontology,\n        open: !args['no-open'],\n        hotReload: !args['no-hot-reload']\n      })\n      \n      // Handle graceful shutdown\n      process.on('SIGINT', async () => {\n        console.log('\\nüõë Shutting down dev server...')\n        await server.stop()\n        process.exit(0)\n      })\n    }\n  }\n}\n\nexport { UnjucksDevServer }\nexport type { DevServerOptions }"