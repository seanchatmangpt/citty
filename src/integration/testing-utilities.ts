/**\n * ðŸ§ª Testing Utilities: Comprehensive Test Framework\n * Custom matchers, fixtures, and testing helpers for ecosystem integration\n * Supports Vitest, Jest, and custom testing scenarios\n */\n\nimport { expect } from 'vitest'\nimport type { MatcherResult } from '@vitest/expect'\nimport { resolve, join } from 'pathe'\nimport { readFile, writeFile, mkdir } from 'node:fs/promises'\nimport { existsSync } from 'node:fs'\nimport { defu } from 'defu'\nimport { UNJUCKS } from '../unjucks'\nimport { loadGraph, toContext, createOntology } from '../untology'\nimport { createTemplateContext } from '../context'\nimport { MemoryCache } from '../cache'\n\n/**\n * Test configuration options\n */\nexport interface TestConfig {\n  /**\n   * Fixtures directory\n   * @default './test/fixtures'\n   */\n  fixturesDir?: string\n  \n  /**\n   * Temporary test directory\n   * @default './test/tmp'\n   */\n  tempDir?: string\n  \n  /**\n   * Enable snapshot testing\n   * @default true\n   */\n  enableSnapshots?: boolean\n  \n  /**\n   * Auto-cleanup test files\n   * @default true\n   */\n  autoCleanup?: boolean\n  \n  /**\n   * Timeout for async operations (ms)\n   * @default 10000\n   */\n  timeout?: number\n  \n  /**\n   * Global test context\n   */\n  globalContext?: Record<string, any>\n}\n\n/**\n * Template test case definition\n */\nexport interface TemplateTestCase {\n  name: string\n  templateId: string\n  ontology?: string\n  context?: Record<string, any>\n  expectedOutput?: string | RegExp | ((output: string) => boolean)\n  expectedFiles?: Array<{\n    path: string\n    content?: string | RegExp | ((content: string) => boolean)\n    exists?: boolean\n  }>\n  shouldFail?: boolean\n  timeout?: number\n}\n\n/**\n * Test fixture manager\n */\nexport class TestFixtures {\n  private config: Required<TestConfig>\n  private cache = new MemoryCache<any>()\n  \n  constructor(config: TestConfig = {}) {\n    this.config = defu(config, {\n      fixturesDir: './test/fixtures',\n      tempDir: './test/tmp', \n      enableSnapshots: true,\n      autoCleanup: true,\n      timeout: 10000,\n      globalContext: {}\n    })\n  }\n  \n  /**\n   * Load test fixture\n   */\n  async loadFixture(name: string): Promise<any> {\n    const cacheKey = `fixture:${name}`\n    \n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)\n    }\n    \n    const fixturePath = resolve(this.config.fixturesDir, `${name}.json`)\n    \n    if (!existsSync(fixturePath)) {\n      throw new Error(`Fixture not found: ${fixturePath}`)\n    }\n    \n    const content = await readFile(fixturePath, 'utf-8')\n    const fixture = JSON.parse(content)\n    \n    this.cache.set(cacheKey, fixture)\n    return fixture\n  }\n  \n  /**\n   * Load ontology fixture\n   */\n  async loadOntologyFixture(name: string): Promise<string> {\n    const ontologyPath = resolve(this.config.fixturesDir, 'ontologies', `${name}.ttl`)\n    \n    if (!existsSync(ontologyPath)) {\n      throw new Error(`Ontology fixture not found: ${ontologyPath}`)\n    }\n    \n    return readFile(ontologyPath, 'utf-8')\n  }\n  \n  /**\n   * Load template fixture\n   */\n  async loadTemplateFixture(name: string): Promise<string> {\n    const templatePath = resolve(this.config.fixturesDir, 'templates', `${name}.njk`)\n    \n    if (!existsSync(templatePath)) {\n      throw new Error(`Template fixture not found: ${templatePath}`)\n    }\n    \n    return readFile(templatePath, 'utf-8')\n  }\n  \n  /**\n   * Create temporary test directory\n   */\n  async createTempDir(testName?: string): Promise<string> {\n    const tempPath = testName \n      ? join(this.config.tempDir, testName, Date.now().toString())\n      : join(this.config.tempDir, Date.now().toString())\n    \n    await mkdir(tempPath, { recursive: true })\n    return tempPath\n  }\n  \n  /**\n   * Cleanup temporary files\n   */\n  async cleanup(): Promise<void> {\n    if (this.config.autoCleanup && existsSync(this.config.tempDir)) {\n      const { rm } = await import('node:fs/promises')\n      await rm(this.config.tempDir, { recursive: true, force: true })\n    }\n  }\n}\n\n/**\n * Template test runner\n */\nexport class TemplateTestRunner {\n  private fixtures: TestFixtures\n  private config: Required<TestConfig>\n  \n  constructor(config: TestConfig = {}) {\n    this.config = defu(config, {\n      fixturesDir: './test/fixtures',\n      tempDir: './test/tmp',\n      enableSnapshots: true,\n      autoCleanup: true,\n      timeout: 10000,\n      globalContext: {}\n    })\n    \n    this.fixtures = new TestFixtures(this.config)\n  }\n  \n  /**\n   * Run a single template test\n   */\n  async runTest(testCase: TemplateTestCase): Promise<{\n    success: boolean\n    result?: any\n    error?: Error\n    duration: number\n  }> {\n    const startTime = Date.now()\n    \n    try {\n      // Setup test environment\n      const tempDir = await this.fixtures.createTempDir(testCase.name)\n      \n      // Initialize template context\n      const templateContext = await createTemplateContext({\n        templatesDir: join(this.config.fixturesDir, 'templates'),\n        outputDir: tempDir,\n        cache: false\n      })\n      \n      // Load ontology if specified\n      let ontologyContext = {}\n      if (testCase.ontology) {\n        const ontologyContent = await this.fixtures.loadOntologyFixture(testCase.ontology)\n        await loadGraph(ontologyContent)\n        ontologyContext = toContext()\n      }\n      \n      // Merge contexts\n      const context = {\n        ...this.config.globalContext,\n        ...ontologyContext,\n        ...testCase.context,\n        $test: {\n          name: testCase.name,\n          tempDir,\n          timestamp: new Date().toISOString()\n        }\n      }\n      \n      // Generate template\n      const result = await UNJUCKS.generateFromOntology(\n        testCase.ontology ? join(this.config.fixturesDir, 'ontologies') : '',\n        testCase.templateId,\n        {\n          context,\n          outputDir: tempDir\n        }\n      )\n      \n      // Check if test should fail\n      if (testCase.shouldFail) {\n        if (result.success) {\n          throw new Error('Test expected to fail but succeeded')\n        }\n        return {\n          success: true,\n          result,\n          duration: Date.now() - startTime\n        }\n      }\n      \n      // Verify success\n      if (!result.success) {\n        throw new Error(`Template generation failed: ${result.errors?.[0]?.message}`)\n      }\n      \n      // Validate expected output\n      if (testCase.expectedOutput && result.files.length > 0) {\n        const output = result.files[0].content\n        \n        if (typeof testCase.expectedOutput === 'string') {\n          if (output !== testCase.expectedOutput) {\n            throw new Error(`Output mismatch. Expected: ${testCase.expectedOutput}, Got: ${output}`)\n          }\n        } else if (testCase.expectedOutput instanceof RegExp) {\n          if (!testCase.expectedOutput.test(output)) {\n            throw new Error(`Output doesn't match pattern: ${testCase.expectedOutput}`)\n          }\n        } else if (typeof testCase.expectedOutput === 'function') {\n          if (!testCase.expectedOutput(output)) {\n            throw new Error('Output validation function returned false')\n          }\n        }\n      }\n      \n      // Validate expected files\n      if (testCase.expectedFiles) {\n        for (const fileSpec of testCase.expectedFiles) {\n          const filePath = join(tempDir, fileSpec.path)\n          \n          if (fileSpec.exists !== false) {\n            if (!existsSync(filePath)) {\n              throw new Error(`Expected file not found: ${fileSpec.path}`)\n            }\n            \n            if (fileSpec.content) {\n              const content = await readFile(filePath, 'utf-8')\n              \n              if (typeof fileSpec.content === 'string') {\n                if (content !== fileSpec.content) {\n                  throw new Error(`File content mismatch for ${fileSpec.path}`)\n                }\n              } else if (fileSpec.content instanceof RegExp) {\n                if (!fileSpec.content.test(content)) {\n                  throw new Error(`File content doesn't match pattern for ${fileSpec.path}`)\n                }\n              } else if (typeof fileSpec.content === 'function') {\n                if (!fileSpec.content(content)) {\n                  throw new Error(`File content validation failed for ${fileSpec.path}`)\n                }\n              }\n            }\n          } else {\n            if (existsSync(filePath)) {\n              throw new Error(`Unexpected file found: ${fileSpec.path}`)\n            }\n          }\n        }\n      }\n      \n      return {\n        success: true,\n        result,\n        duration: Date.now() - startTime\n      }\n      \n    } catch (error) {\n      return {\n        success: false,\n        error: error as Error,\n        duration: Date.now() - startTime\n      }\n    }\n  }\n  \n  /**\n   * Run multiple template tests\n   */\n  async runTests(testCases: TemplateTestCase[]): Promise<{\n    passed: number\n    failed: number\n    results: Array<{ testCase: TemplateTestCase; result: any }>\n  }> {\n    const results = []\n    let passed = 0\n    let failed = 0\n    \n    for (const testCase of testCases) {\n      const result = await this.runTest(testCase)\n      results.push({ testCase, result })\n      \n      if (result.success) {\n        passed++\n      } else {\n        failed++\n        console.error(`Test failed: ${testCase.name}`, result.error)\n      }\n    }\n    \n    return { passed, failed, results }\n  }\n  \n  /**\n   * Cleanup test resources\n   */\n  async cleanup(): Promise<void> {\n    await this.fixtures.cleanup()\n  }\n}\n\n/**\n * Custom matchers for template testing\n */\nexport const templateMatchers = {\n  /**\n   * Check if template generates expected output\n   */\n  toGenerateTemplate(\n    received: any,\n    templateId: string,\n    expectedOutput?: string | RegExp\n  ): MatcherResult {\n    const pass = received.success && \n                 received.files && \n                 received.files.length > 0 &&\n                 (expectedOutput \n                   ? typeof expectedOutput === 'string' \n                     ? received.files[0].content === expectedOutput\n                     : expectedOutput.test(received.files[0].content)\n                   : true)\n    \n    return {\n      pass,\n      message: () => \n        pass\n          ? `Expected template ${templateId} not to generate output`\n          : `Expected template ${templateId} to generate ${expectedOutput ? 'matching ' : ''}output`\n    }\n  },\n  \n  /**\n   * Check if template generates files\n   */\n  toGenerateFiles(received: any, expectedCount?: number): MatcherResult {\n    const actualCount = received.files ? received.files.length : 0\n    const pass = expectedCount ? actualCount === expectedCount : actualCount > 0\n    \n    return {\n      pass,\n      message: () => \n        pass\n          ? `Expected not to generate ${expectedCount || 'any'} files`\n          : `Expected to generate ${expectedCount || 'some'} files, got ${actualCount}`\n    }\n  },\n  \n  /**\n   * Check if ontology context contains entities\n   */\n  toContainEntities(received: any, entityTypes: string[]): MatcherResult {\n    const hasEntities = Array.isArray(received) && \n                       entityTypes.every(type => \n                         received.some((entity: any) => entity.type === type)\n                       )\n    \n    return {\n      pass: hasEntities,\n      message: () => \n        hasEntities\n          ? `Expected not to contain entities: ${entityTypes.join(', ')}`\n          : `Expected to contain entities: ${entityTypes.join(', ')}`\n    }\n  },\n  \n  /**\n   * Check template compilation time\n   */\n  toCompileWithin(received: any, maxDuration: number): MatcherResult {\n    const duration = received.duration || 0\n    const pass = duration <= maxDuration\n    \n    return {\n      pass,\n      message: () => \n        pass\n          ? `Expected compilation to take more than ${maxDuration}ms`\n          : `Expected compilation to complete within ${maxDuration}ms, took ${duration}ms`\n    }\n  }\n}\n\n/**\n * Test helper functions\n */\nexport class TestHelpers {\n  /**\n   * Create mock ontology data\n   */\n  static createMockOntology(entities: Array<{\n    id: string\n    type: string\n    properties?: Record<string, any>\n  }>): string {\n    let ontology = '@prefix ex: <http://example.org/> .\\n'\n    ontology += '@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\\n\\n'\n    \n    for (const entity of entities) {\n      ontology += `ex:${entity.id} rdf:type ex:${entity.type} .\\n`\n      \n      if (entity.properties) {\n        for (const [key, value] of Object.entries(entity.properties)) {\n          if (typeof value === 'string') {\n            ontology += `ex:${entity.id} ex:${key} \"${value}\" .\\n`\n          } else {\n            ontology += `ex:${entity.id} ex:${key} \"${JSON.stringify(value)}\" .\\n`\n          }\n        }\n      }\n    }\n    \n    return ontology\n  }\n  \n  /**\n   * Create test template\n   */\n  static createTestTemplate(\n    content: string,\n    frontMatter: Record<string, any> = {}\n  ): string {\n    const fm = Object.keys(frontMatter).length > 0 \n      ? '---\\n' + Object.entries(frontMatter)\n          .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)\n          .join('\\n') + '\\n---\\n'\n      : ''\n    \n    return fm + content\n  }\n  \n  /**\n   * Wait for async operation\n   */\n  static async waitFor(\n    condition: () => boolean | Promise<boolean>,\n    timeout = 5000,\n    interval = 100\n  ): Promise<void> {\n    const start = Date.now()\n    \n    while (Date.now() - start < timeout) {\n      if (await condition()) {\n        return\n      }\n      await new Promise(resolve => setTimeout(resolve, interval))\n    }\n    \n    throw new Error(`Condition not met within ${timeout}ms`)\n  }\n  \n  /**\n   * Generate random test data\n   */\n  static generateTestData(type: 'string' | 'number' | 'boolean' | 'array' | 'object', size?: number): any {\n    switch (type) {\n      case 'string':\n        return Math.random().toString(36).substring(2, size || 15)\n      \n      case 'number':\n        return Math.floor(Math.random() * (size || 1000))\n      \n      case 'boolean':\n        return Math.random() < 0.5\n      \n      case 'array':\n        return Array.from({ length: size || 5 }, () => this.generateTestData('string'))\n      \n      case 'object':\n        const obj: Record<string, any> = {}\n        for (let i = 0; i < (size || 3); i++) {\n          obj[this.generateTestData('string')] = this.generateTestData('string')\n        }\n        return obj\n      \n      default:\n        return null\n    }\n  }\n}\n\n/**\n * Setup test environment\n */\nexport function setupTestEnvironment(config: TestConfig = {}) {\n  const testConfig = defu(config, {\n    fixturesDir: './test/fixtures',\n    tempDir: './test/tmp',\n    enableSnapshots: true,\n    autoCleanup: true,\n    timeout: 10000,\n    globalContext: {}\n  })\n  \n  const fixtures = new TestFixtures(testConfig)\n  const runner = new TemplateTestRunner(testConfig)\n  \n  // Register custom matchers\n  if (typeof expect !== 'undefined') {\n    expect.extend(templateMatchers)\n  }\n  \n  // Global cleanup\n  if (typeof afterAll !== 'undefined') {\n    afterAll(async () => {\n      await fixtures.cleanup()\n      await runner.cleanup()\n    })\n  }\n  \n  return {\n    fixtures,\n    runner,\n    helpers: TestHelpers,\n    config: testConfig\n  }\n}\n\n/**\n * Create test suite for templates\n */\nexport function createTemplateTestSuite(\n  name: string,\n  testCases: TemplateTestCase[],\n  config: TestConfig = {}\n) {\n  const { runner } = setupTestEnvironment(config)\n  \n  if (typeof describe !== 'undefined' && typeof it !== 'undefined') {\n    describe(name, () => {\n      for (const testCase of testCases) {\n        it(testCase.name, async () => {\n          const result = await runner.runTest(testCase)\n          \n          if (!result.success) {\n            throw result.error\n          }\n          \n          expect(result.result).toBeTruthy()\n        }, testCase.timeout || config.timeout)\n      }\n    })\n  }\n}\n\n// Type augmentation for custom matchers\ndeclare module 'vitest' {\n  interface Assertion<T = any> {\n    toGenerateTemplate(templateId: string, expectedOutput?: string | RegExp): T\n    toGenerateFiles(expectedCount?: number): T\n    toContainEntities(entityTypes: string[]): T\n    toCompileWithin(maxDuration: number): T\n  }\n}\n\nexport {\n  TestConfig,\n  TemplateTestCase,\n  TestFixtures,\n  TemplateTestRunner\n}"