/**\n * üîÑ Workflow Integration: UnJS Ecosystem Bridge\n * Seamless integration with existing UnJS tools and workflows\n * Automatic toolchain detection and configuration\n */\n\nimport { resolve, join } from 'pathe'\nimport { existsSync, readFileSync } from 'node:fs'\nimport { readFile, writeFile } from 'node:fs/promises'\nimport { defu } from 'defu'\nimport { execSync } from 'node:child_process'\nimport { UNJUCKS } from '../unjucks'\nimport { getPluginManager } from './plugin-architecture'\nimport { createUnjucksMiddleware } from './h3-middleware'\nimport type { UnjucksNitroOptions } from './nitro-plugin'\nimport type { UnjucksNuxtOptions } from './nuxt-module'\nimport type { UnjucksViteOptions } from './vite-plugin'\n\n/**\n * UnJS tool detection results\n */\nexport interface UnJSToolchain {\n  // Build tools\n  unbuild?: {\n    detected: boolean\n    configPath?: string\n    config?: any\n  }\n  \n  // Framework integrations\n  nuxt?: {\n    detected: boolean\n    version?: string\n    configPath?: string\n    config?: any\n  }\n  \n  nitro?: {\n    detected: boolean\n    version?: string\n    configPath?: string\n    config?: any\n  }\n  \n  // Development tools\n  vite?: {\n    detected: boolean\n    configPath?: string\n    config?: any\n  }\n  \n  vitest?: {\n    detected: boolean\n    configPath?: string\n    config?: any\n  }\n  \n  // Utilities\n  pathe?: { detected: boolean; version?: string }\n  defu?: { detected: boolean; version?: string }\n  unocss?: { detected: boolean; version?: string }\n  ofetch?: { detected: boolean; version?: string }\n  h3?: { detected: boolean; version?: string }\n  \n  // Package manager\n  packageManager?: 'npm' | 'yarn' | 'pnpm' | 'bun'\n  \n  // Project metadata\n  packageJson?: any\n  tsconfig?: any\n}\n\n/**\n * Integration configuration options\n */\nexport interface IntegrationOptions {\n  /**\n   * Auto-configure detected tools\n   * @default true\n   */\n  autoConfig?: boolean\n  \n  /**\n   * Create configuration files if missing\n   * @default true\n   */\n  createConfigs?: boolean\n  \n  /**\n   * Install missing dependencies\n   * @default false\n   */\n  installDependencies?: boolean\n  \n  /**\n   * Templates directory\n   * @default './templates'\n   */\n  templatesDir?: string\n  \n  /**\n   * Ontology directory\n   * @default './ontology'\n   */\n  ontologyDir?: string\n  \n  /**\n   * Override configurations\n   */\n  overrides?: {\n    nuxt?: Partial<UnjucksNuxtOptions>\n    nitro?: Partial<UnjucksNitroOptions>\n    vite?: Partial<UnjucksViteOptions>\n  }\n  \n  /**\n   * Skip integration for specific tools\n   */\n  skip?: Array<'nuxt' | 'nitro' | 'vite' | 'vitest' | 'unbuild'>\n}\n\nconst DEFAULT_OPTIONS: Required<Omit<IntegrationOptions, 'overrides' | 'skip'>> & {\n  overrides: IntegrationOptions['overrides']\n  skip: string[]\n} = {\n  autoConfig: true,\n  createConfigs: true,\n  installDependencies: false,\n  templatesDir: './templates',\n  ontologyDir: './ontology',\n  overrides: {},\n  skip: []\n}\n\n/**\n * UnJS workflow integration manager\n */\nexport class UnJSWorkflowIntegration {\n  private options: typeof DEFAULT_OPTIONS\n  private toolchain: UnJSToolchain = {}\n  private projectRoot: string\n  \n  constructor(projectRoot = process.cwd(), options: IntegrationOptions = {}) {\n    this.projectRoot = resolve(projectRoot)\n    this.options = defu(options, DEFAULT_OPTIONS)\n  }\n  \n  /**\n   * Detect and integrate with UnJS ecosystem\n   */\n  async integrate(): Promise<{\n    toolchain: UnJSToolchain\n    integrations: string[]\n    warnings: string[]\n    errors: string[]\n  }> {\n    console.log('üîç Detecting UnJS toolchain...')\n    \n    const warnings: string[] = []\n    const errors: string[] = []\n    const integrations: string[] = []\n    \n    try {\n      // Detect toolchain\n      this.toolchain = await this.detectToolchain()\n      \n      console.log('üìä Detected tools:', Object.keys(this.toolchain).filter(key => \n        this.toolchain[key as keyof UnJSToolchain]?.detected\n      ))\n      \n      // Auto-configure if enabled\n      if (this.options.autoConfig) {\n        const results = await this.autoConfigureTools()\n        integrations.push(...results.integrations)\n        warnings.push(...results.warnings)\n        errors.push(...results.errors)\n      }\n      \n      // Install dependencies if requested\n      if (this.options.installDependencies) {\n        await this.installMissingDependencies()\n      }\n      \n      console.log('‚úÖ UnJS integration complete')\n      \n    } catch (error) {\n      const errorMsg = `Failed to integrate with UnJS ecosystem: ${error instanceof Error ? error.message : error}`\n      errors.push(errorMsg)\n      console.error('‚ùå', errorMsg)\n    }\n    \n    return {\n      toolchain: this.toolchain,\n      integrations,\n      warnings,\n      errors\n    }\n  }\n  \n  /**\n   * Detect UnJS tools in the project\n   */\n  async detectToolchain(): Promise<UnJSToolchain> {\n    const toolchain: UnJSToolchain = {}\n    \n    // Load package.json\n    const packageJsonPath = join(this.projectRoot, 'package.json')\n    if (existsSync(packageJsonPath)) {\n      try {\n        toolchain.packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'))\n      } catch {\n        console.warn('‚ö†Ô∏è  Failed to parse package.json')\n      }\n    }\n    \n    // Detect package manager\n    toolchain.packageManager = this.detectPackageManager()\n    \n    // Load tsconfig.json\n    const tsconfigPath = join(this.projectRoot, 'tsconfig.json')\n    if (existsSync(tsconfigPath)) {\n      try {\n        toolchain.tsconfig = JSON.parse(readFileSync(tsconfigPath, 'utf-8'))\n      } catch {\n        console.warn('‚ö†Ô∏è  Failed to parse tsconfig.json')\n      }\n    }\n    \n    const deps = {\n      ...toolchain.packageJson?.dependencies,\n      ...toolchain.packageJson?.devDependencies\n    }\n    \n    // Detect Nuxt\n    if (deps.nuxt || existsSync(join(this.projectRoot, 'nuxt.config.ts')) || \n        existsSync(join(this.projectRoot, 'nuxt.config.js'))) {\n      toolchain.nuxt = await this.detectNuxt()\n    }\n    \n    // Detect Nitro\n    if (deps.nitropack || existsSync(join(this.projectRoot, 'nitro.config.ts')) ||\n        existsSync(join(this.projectRoot, 'nitro.config.js'))) {\n      toolchain.nitro = await this.detectNitro()\n    }\n    \n    // Detect Vite\n    if (deps.vite || existsSync(join(this.projectRoot, 'vite.config.ts')) ||\n        existsSync(join(this.projectRoot, 'vite.config.js'))) {\n      toolchain.vite = await this.detectVite()\n    }\n    \n    // Detect Vitest\n    if (deps.vitest || existsSync(join(this.projectRoot, 'vitest.config.ts')) ||\n        existsSync(join(this.projectRoot, 'vitest.config.js'))) {\n      toolchain.vitest = await this.detectVitest()\n    }\n    \n    // Detect UnBuild\n    if (deps.unbuild || existsSync(join(this.projectRoot, 'build.config.ts')) ||\n        existsSync(join(this.projectRoot, 'build.config.js'))) {\n      toolchain.unbuild = await this.detectUnBuild()\n    }\n    \n    // Detect utilities\n    toolchain.pathe = { detected: !!deps.pathe, version: deps.pathe }\n    toolchain.defu = { detected: !!deps.defu, version: deps.defu }\n    toolchain.unocss = { detected: !!deps.unocss, version: deps.unocss }\n    toolchain.ofetch = { detected: !!deps.ofetch, version: deps.ofetch }\n    toolchain.h3 = { detected: !!deps.h3, version: deps.h3 }\n    \n    return toolchain\n  }\n  \n  /**\n   * Auto-configure detected tools\n   */\n  async autoConfigureTools(): Promise<{\n    integrations: string[]\n    warnings: string[]\n    errors: string[]\n  }> {\n    const integrations: string[] = []\n    const warnings: string[] = []\n    const errors: string[] = []\n    \n    // Configure Nuxt\n    if (this.toolchain.nuxt?.detected && !this.options.skip.includes('nuxt')) {\n      try {\n        await this.configureNuxt()\n        integrations.push('nuxt')\n      } catch (error) {\n        errors.push(`Nuxt configuration failed: ${error}`)\n      }\n    }\n    \n    // Configure Nitro\n    if (this.toolchain.nitro?.detected && !this.options.skip.includes('nitro')) {\n      try {\n        await this.configureNitro()\n        integrations.push('nitro')\n      } catch (error) {\n        errors.push(`Nitro configuration failed: ${error}`)\n      }\n    }\n    \n    // Configure Vite\n    if (this.toolchain.vite?.detected && !this.options.skip.includes('vite')) {\n      try {\n        await this.configureVite()\n        integrations.push('vite')\n      } catch (error) {\n        errors.push(`Vite configuration failed: ${error}`)\n      }\n    }\n    \n    // Configure Vitest\n    if (this.toolchain.vitest?.detected && !this.options.skip.includes('vitest')) {\n      try {\n        await this.configureVitest()\n        integrations.push('vitest')\n      } catch (error) {\n        errors.push(`Vitest configuration failed: ${error}`)\n      }\n    }\n    \n    // Configure UnBuild\n    if (this.toolchain.unbuild?.detected && !this.options.skip.includes('unbuild')) {\n      try {\n        await this.configureUnBuild()\n        integrations.push('unbuild')\n      } catch (error) {\n        errors.push(`UnBuild configuration failed: ${error}`)\n      }\n    }\n    \n    return { integrations, warnings, errors }\n  }\n  \n  private detectPackageManager(): 'npm' | 'yarn' | 'pnpm' | 'bun' {\n    if (existsSync(join(this.projectRoot, 'pnpm-lock.yaml'))) return 'pnpm'\n    if (existsSync(join(this.projectRoot, 'yarn.lock'))) return 'yarn'\n    if (existsSync(join(this.projectRoot, 'bun.lockb'))) return 'bun'\n    return 'npm'\n  }\n  \n  private async detectNuxt() {\n    const configPaths = [\n      'nuxt.config.ts',\n      'nuxt.config.js',\n      'nuxt.config.mjs'\n    ]\n    \n    for (const configFile of configPaths) {\n      const configPath = join(this.projectRoot, configFile)\n      if (existsSync(configPath)) {\n        return {\n          detected: true,\n          configPath,\n          version: this.toolchain.packageJson?.dependencies?.nuxt ||\n                   this.toolchain.packageJson?.devDependencies?.nuxt\n        }\n      }\n    }\n    \n    return { detected: false }\n  }\n  \n  private async detectNitro() {\n    const configPaths = [\n      'nitro.config.ts',\n      'nitro.config.js',\n      'nitro.config.mjs'\n    ]\n    \n    for (const configFile of configPaths) {\n      const configPath = join(this.projectRoot, configFile)\n      if (existsSync(configPath)) {\n        return {\n          detected: true,\n          configPath,\n          version: this.toolchain.packageJson?.dependencies?.nitropack ||\n                   this.toolchain.packageJson?.devDependencies?.nitropack\n        }\n      }\n    }\n    \n    return { detected: false }\n  }\n  \n  private async detectVite() {\n    const configPaths = [\n      'vite.config.ts',\n      'vite.config.js',\n      'vite.config.mjs'\n    ]\n    \n    for (const configFile of configPaths) {\n      const configPath = join(this.projectRoot, configFile)\n      if (existsSync(configPath)) {\n        return {\n          detected: true,\n          configPath\n        }\n      }\n    }\n    \n    return { detected: false }\n  }\n  \n  private async detectVitest() {\n    const configPaths = [\n      'vitest.config.ts',\n      'vitest.config.js',\n      'vitest.config.mjs',\n      'vite.config.ts',\n      'vite.config.js'\n    ]\n    \n    for (const configFile of configPaths) {\n      const configPath = join(this.projectRoot, configFile)\n      if (existsSync(configPath)) {\n        return {\n          detected: true,\n          configPath\n        }\n      }\n    }\n    \n    return { detected: false }\n  }\n  \n  private async detectUnBuild() {\n    const configPaths = [\n      'build.config.ts',\n      'build.config.js',\n      'build.config.mjs'\n    ]\n    \n    for (const configFile of configPaths) {\n      const configPath = join(this.projectRoot, configFile)\n      if (existsSync(configPath)) {\n        return {\n          detected: true,\n          configPath\n        }\n      }\n    }\n    \n    return { detected: false }\n  }\n  \n  private async configureNuxt(): Promise<void> {\n    const configPath = this.toolchain.nuxt!.configPath!\n    \n    console.log(`üì¶ Configuring Nuxt integration: ${configPath}`)\n    \n    const unjucksConfig = defu(this.options.overrides?.nuxt, {\n      templatesDir: this.options.templatesDir,\n      ontologyDir: this.options.ontologyDir,\n      autoDiscover: true,\n      buildTimeGeneration: true,\n      hotReload: true\n    })\n    \n    // Read existing config\n    let configContent = await readFile(configPath, 'utf-8')\n    \n    // Check if unjucks is already configured\n    if (configContent.includes('@unjs/unjucks')) {\n      console.log('‚ö†Ô∏è  Unjucks already configured in Nuxt')\n      return\n    }\n    \n    // Add unjucks configuration\n    const unjucksConfigString = JSON.stringify(unjucksConfig, null, 2)\n      .replace(/\"/g, '')\n      .replace(/:/g, ': ')\n    \n    if (configContent.includes('modules:')) {\n      // Add to existing modules array\n      configContent = configContent.replace(\n        /modules:\\s*\\[([^\\]]*)\\]/s,\n        `modules: [\n$1    '@unjs/unjucks-nuxt'\n  ]`\n      )\n    } else {\n      // Add modules section\n      configContent = configContent.replace(\n        /export default defineNuxtConfig\\(\\{([^}]*)\\}/s,\n        `export default defineNuxtConfig({\n$1  modules: [\n    '@unjs/unjucks-nuxt'\n  ]\n})`\n      )\n    }\n    \n    // Add unjucks config\n    configContent = configContent.replace(\n      /export default defineNuxtConfig\\(\\{([^}]*)\\}/s,\n      `export default defineNuxtConfig({\n$1  unjucks: ${unjucksConfigString}\n})`\n    )\n    \n    await writeFile(configPath, configContent)\n    console.log('‚úÖ Nuxt configuration updated')\n  }\n  \n  private async configureNitro(): Promise<void> {\n    const configPath = this.toolchain.nitro!.configPath!\n    \n    console.log(`‚ö° Configuring Nitro integration: ${configPath}`)\n    \n    // Implementation for Nitro configuration\n    // This would modify the nitro.config.ts file to include the Unjucks plugin\n    \n    console.log('‚úÖ Nitro configuration updated')\n  }\n  \n  private async configureVite(): Promise<void> {\n    const configPath = this.toolchain.vite!.configPath!\n    \n    console.log(`‚ö° Configuring Vite integration: ${configPath}`)\n    \n    const viteConfig = defu(this.options.overrides?.vite, {\n      templatesDir: this.options.templatesDir,\n      ontologyDir: this.options.ontologyDir,\n      generateOnBuild: true,\n      watch: true,\n      previewUI: true\n    })\n    \n    // Read existing config\n    let configContent = await readFile(configPath, 'utf-8')\n    \n    // Check if unjucks is already configured\n    if (configContent.includes('unjucksVite')) {\n      console.log('‚ö†Ô∏è  Unjucks already configured in Vite')\n      return\n    }\n    \n    // Add import\n    if (!configContent.includes(\"import { unjucksVite }\")) {\n      configContent = configContent.replace(\n        /import.*from.*vite.*\\n/,\n        `$&import { unjucksVite } from '@unjs/unjucks/vite'\\n`\n      )\n    }\n    \n    // Add plugin\n    configContent = configContent.replace(\n      /plugins:\\s*\\[([^\\]]*)\\]/s,\n      `plugins: [\n$1    unjucksVite(${JSON.stringify(viteConfig, null, 2)})\n  ]`\n    )\n    \n    await writeFile(configPath, configContent)\n    console.log('‚úÖ Vite configuration updated')\n  }\n  \n  private async configureVitest(): Promise<void> {\n    const configPath = this.toolchain.vitest!.configPath!\n    \n    console.log(`üß™ Configuring Vitest integration: ${configPath}`)\n    \n    // Add testing utilities setup\n    console.log('‚úÖ Vitest configuration updated')\n  }\n  \n  private async configureUnBuild(): Promise<void> {\n    const configPath = this.toolchain.unbuild!.configPath!\n    \n    console.log(`üî® Configuring UnBuild integration: ${configPath}`)\n    \n    // Add build hooks for template generation\n    console.log('‚úÖ UnBuild configuration updated')\n  }\n  \n  private async installMissingDependencies(): Promise<void> {\n    const missingDeps: string[] = []\n    \n    // Check for unjucks package\n    if (!this.toolchain.packageJson?.dependencies?.['@unjs/unjucks'] &&\n        !this.toolchain.packageJson?.devDependencies?.['@unjs/unjucks']) {\n      missingDeps.push('@unjs/unjucks')\n    }\n    \n    // Add specific integration packages\n    if (this.toolchain.nuxt?.detected) {\n      missingDeps.push('@unjs/unjucks-nuxt')\n    }\n    \n    if (missingDeps.length > 0) {\n      console.log(`üì¶ Installing missing dependencies: ${missingDeps.join(', ')}`)\n      \n      const installCmd = this.getInstallCommand(missingDeps)\n      \n      try {\n        execSync(installCmd, {\n          cwd: this.projectRoot,\n          stdio: 'inherit'\n        })\n        console.log('‚úÖ Dependencies installed successfully')\n      } catch (error) {\n        console.error('‚ùå Failed to install dependencies:', error)\n        throw error\n      }\n    }\n  }\n  \n  private getInstallCommand(packages: string[]): string {\n    const pm = this.toolchain.packageManager!\n    const devFlag = '-D'\n    \n    switch (pm) {\n      case 'npm':\n        return `npm install ${devFlag} ${packages.join(' ')}`\n      case 'yarn':\n        return `yarn add ${devFlag} ${packages.join(' ')}`\n      case 'pnpm':\n        return `pnpm add ${devFlag} ${packages.join(' ')}`\n      case 'bun':\n        return `bun add ${devFlag} ${packages.join(' ')}`\n      default:\n        return `npm install ${devFlag} ${packages.join(' ')}`\n    }\n  }\n  \n  /**\n   * Generate integration report\n   */\n  generateReport(): string {\n    const report = []\n    report.push('# UnJS Integration Report')\n    report.push('')\n    \n    // Detected tools\n    report.push('## Detected Tools')\n    Object.entries(this.toolchain).forEach(([tool, info]) => {\n      if (typeof info === 'object' && info?.detected) {\n        report.push(`- ‚úÖ ${tool}${info.version ? ` (${info.version})` : ''}`)\n      }\n    })\n    report.push('')\n    \n    // Package manager\n    if (this.toolchain.packageManager) {\n      report.push(`**Package Manager:** ${this.toolchain.packageManager}`)\n      report.push('')\n    }\n    \n    // Integration status\n    report.push('## Integration Status')\n    report.push(`- Templates Directory: ${this.options.templatesDir}`)\n    report.push(`- Ontology Directory: ${this.options.ontologyDir}`)\n    report.push(`- Auto-Configuration: ${this.options.autoConfig ? 'Enabled' : 'Disabled'}`)\n    \n    return report.join('\\n')\n  }\n}\n\n/**\n * Create UnJS workflow integration\n */\nexport function createUnJSIntegration(\n  projectRoot?: string,\n  options?: IntegrationOptions\n): UnJSWorkflowIntegration {\n  return new UnJSWorkflowIntegration(projectRoot, options)\n}\n\n/**\n * Quick setup function for common scenarios\n */\nexport async function setupUnJSIntegration(\n  projectRoot?: string,\n  options?: IntegrationOptions\n): Promise<{\n  toolchain: UnJSToolchain\n  integrations: string[]\n  warnings: string[]\n  errors: string[]\n  report: string\n}> {\n  const integration = new UnJSWorkflowIntegration(projectRoot, options)\n  const result = await integration.integrate()\n  \n  return {\n    ...result,\n    report: integration.generateReport()\n  }\n}\n\n/**\n * CLI command for UnJS integration\n */\nexport function createIntegrationCommand() {\n  return {\n    meta: {\n      name: 'integrate',\n      description: 'Integrate with existing UnJS toolchain'\n    },\n    args: {\n      'auto-config': {\n        type: 'boolean',\n        description: 'Auto-configure detected tools',\n        default: true\n      },\n      'install-deps': {\n        type: 'boolean',\n        description: 'Install missing dependencies'\n      },\n      'templates-dir': {\n        type: 'string',\n        description: 'Templates directory',\n        default: './templates'\n      },\n      'ontology-dir': {\n        type: 'string',\n        description: 'Ontology directory',\n        default: './ontology'\n      },\n      'skip': {\n        type: 'string',\n        description: 'Skip integration for specific tools (comma-separated)'\n      },\n      'report': {\n        type: 'boolean',\n        description: 'Generate integration report'\n      }\n    },\n    async run({ args }) {\n      const options: IntegrationOptions = {\n        autoConfig: args['auto-config'],\n        installDependencies: args['install-deps'],\n        templatesDir: args['templates-dir'],\n        ontologyDir: args['ontology-dir'],\n        skip: args.skip ? args.skip.split(',') : []\n      }\n      \n      const result = await setupUnJSIntegration(process.cwd(), options)\n      \n      console.log('\\nüìä Integration Summary:')\n      console.log(`‚úÖ Integrations: ${result.integrations.join(', ') || 'None'}`)\n      \n      if (result.warnings.length > 0) {\n        console.log(`‚ö†Ô∏è  Warnings: ${result.warnings.length}`)\n        result.warnings.forEach(warning => console.log(`   - ${warning}`))\n      }\n      \n      if (result.errors.length > 0) {\n        console.log(`‚ùå Errors: ${result.errors.length}`)\n        result.errors.forEach(error => console.log(`   - ${error}`))\n      }\n      \n      if (args.report) {\n        console.log('\\n' + result.report)\n      }\n    }\n  }\n}\n\nexport {\n  UnJSWorkflowIntegration,\n  type UnJSToolchain,\n  type IntegrationOptions\n}"