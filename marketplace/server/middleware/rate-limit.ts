import { LRUCache } from 'lru-cache'\n\n// Rate limiting middleware for Nuxt API routes\ninterface RateLimitEntry {\n  count: number\n  resetTime: number\n}\n\nconst rateLimitCache = new LRUCache<string, RateLimitEntry>({\n  max: 10000, // Maximum number of IPs to track\n  ttl: 15 * 60 * 1000, // 15 minutes TTL\n})\n\n// Different rate limits for different endpoints\nconst rateLimits = {\n  '/api/search': { requests: 60, windowMs: 60000 }, // 60 requests per minute\n  '/api/items': { requests: 100, windowMs: 60000 }, // 100 requests per minute\n  '/api/auctions/bid': { requests: 10, windowMs: 60000 }, // 10 bids per minute\n  '/api/auth': { requests: 5, windowMs: 60000 }, // 5 auth attempts per minute\n  default: { requests: 200, windowMs: 60000 } // Default 200 requests per minute\n}\n\nexport default defineEventHandler(async (event) => {\n  // Only apply rate limiting to API routes\n  if (!event.node.req.url?.startsWith('/api/')) {\n    return\n  }\n  \n  const clientIP = getClientIP(event) || 'unknown'\n  const requestPath = event.node.req.url\n  const now = Date.now()\n  \n  // Determine rate limit for this endpoint\n  let rateLimit = rateLimits.default\n  for (const [path, limit] of Object.entries(rateLimits)) {\n    if (path !== 'default' && requestPath?.includes(path)) {\n      rateLimit = limit\n      break\n    }\n  }\n  \n  // Create cache key\n  const cacheKey = `${clientIP}:${requestPath?.split('?')[0]}`\n  \n  // Get or initialize rate limit entry\n  let entry = rateLimitCache.get(cacheKey)\n  if (!entry || now > entry.resetTime) {\n    entry = {\n      count: 0,\n      resetTime: now + rateLimit.windowMs\n    }\n  }\n  \n  // Increment request count\n  entry.count++\n  rateLimitCache.set(cacheKey, entry)\n  \n  // Check if rate limit exceeded\n  if (entry.count > rateLimit.requests) {\n    const retryAfter = Math.ceil((entry.resetTime - now) / 1000)\n    \n    // Set rate limit headers\n    setResponseHeaders(event, {\n      'X-RateLimit-Limit': rateLimit.requests.toString(),\n      'X-RateLimit-Remaining': '0',\n      'X-RateLimit-Reset': new Date(entry.resetTime).toISOString(),\n      'Retry-After': retryAfter.toString()\n    })\n    \n    throw createError({\n      statusCode: 429,\n      statusMessage: 'Too Many Requests',\n      data: {\n        message: `Rate limit exceeded. Try again in ${retryAfter} seconds.`,\n        retryAfter,\n        limit: rateLimit.requests,\n        windowMs: rateLimit.windowMs\n      }\n    })\n  }\n  \n  // Set rate limit headers for successful requests\n  setResponseHeaders(event, {\n    'X-RateLimit-Limit': rateLimit.requests.toString(),\n    'X-RateLimit-Remaining': (rateLimit.requests - entry.count).toString(),\n    'X-RateLimit-Reset': new Date(entry.resetTime).toISOString()\n  })\n})"