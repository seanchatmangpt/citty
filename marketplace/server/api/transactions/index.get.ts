import { z } from 'zod'
import jwt from 'jsonwebtoken'

const transactionQuerySchema = z.object({
  status: z.enum(['pending', 'completed', 'failed', 'cancelled', 'refunded', 'all']).default('all'),
  type: z.enum(['purchase', 'sale', 'auction', 'refund', 'all']).default('all'),
  dateFrom: z.string().datetime().optional(),
  dateTo: z.string().datetime().optional(),
  minAmount: z.coerce.number().min(0).optional(),
  maxAmount: z.coerce.number().min(0).optional(),
  sortBy: z.enum(['date', 'amount', 'status']).default('date'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20)
})

// Mock authentication
function verifyToken(token: string) {
  try {
    const config = useRuntimeConfig()
    return jwt.verify(token, config.jwtSecret) as { id: string, email: string, role: string }
  } catch {
    throw createError({
      statusCode: 401,
      statusMessage: 'Invalid or expired token'
    })
  }
}

// Mock transaction database
const mockTransactions = [
  {
    id: 'txn-001',
    type: 'purchase',
    status: 'completed',
    buyerId: 'user-1',
    buyerName: 'John Doe',
    sellerId: 'user-2',
    sellerName: 'Jane Smith',
    itemId: '2',
    itemName: 'Advanced Auth Plugin',
    itemType: 'plugin',
    amount: 79.99,
    currency: 'USD',
    platformFee: 7.99,
    sellerAmount: 72.00,
    paymentMethod: 'credit_card',
    paymentProcessor: 'stripe',
    paymentIntentId: 'pi_3OxGmXEv1LmQrGsV1qFqJKZv',
    createdAt: new Date('2024-03-10T14:30:00Z'),
    completedAt: new Date('2024-03-10T14:30:15Z'),
    escrowReleaseDate: new Date('2024-03-17T14:30:00Z'),
    metadata: {
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
      ipAddress: '192.168.1.100',
      downloadCount: 3,
      licenseKey: 'lic_auth_plugin_xyz123'
    }
  },\n  {\n    id: 'txn-002',\n    type: 'auction',\n    status: 'completed',\n    buyerId: 'user-3',\n    buyerName: 'Alice Cooper',\n    sellerId: 'user-1',\n    sellerName: 'John Doe',\n    itemId: '1',\n    itemName: 'Vue CLI Template Pro',\n    itemType: 'template',\n    auctionId: 'auction-1',\n    winningBid: 125.50,\n    amount: 125.50,\n    currency: 'USD',\n    platformFee: 12.55,\n    sellerAmount: 112.95,\n    paymentMethod: 'paypal',\n    paymentProcessor: 'paypal',\n    paymentIntentId: 'PAYID-MW2XQ6I08D05832KU4567890',\n    createdAt: new Date('2024-03-08T20:15:00Z'),\n    completedAt: new Date('2024-03-08T20:17:30Z'),\n    escrowReleaseDate: new Date('2024-03-15T20:15:00Z'),\n    metadata: {\n      auctionEndTime: new Date('2024-03-08T20:00:00Z'),\n      totalBids: 18,\n      startingPrice: 25.00,\n      reservePrice: 75.00,\n      downloadCount: 1,\n      licenseKey: 'lic_vue_template_abc456'\n    }\n  },\n  {\n    id: 'txn-003',\n    type: 'purchase',\n    status: 'pending',\n    buyerId: 'user-4',\n    buyerName: 'Bob Wilson',\n    sellerId: 'user-3',\n    sellerName: 'Database Corp',\n    itemId: '4',\n    itemName: 'Database Migration Tool',\n    itemType: 'tool',\n    amount: 129.99,\n    currency: 'USD',\n    platformFee: 13.00,\n    sellerAmount: 116.99,\n    paymentMethod: 'bank_transfer',\n    paymentProcessor: 'wise',\n    paymentIntentId: 'wise_txn_def789',\n    createdAt: new Date('2024-03-12T09:20:00Z'),\n    expectedCompletionDate: new Date('2024-03-14T09:20:00Z'),\n    metadata: {\n      bankTransferRef: 'REF123456789',\n      requiresManualReview: true\n    }\n  },\n  {\n    id: 'txn-004',\n    type: 'refund',\n    status: 'completed',\n    originalTransactionId: 'txn-001',\n    buyerId: 'user-1',\n    buyerName: 'John Doe',\n    sellerId: 'user-2',\n    sellerName: 'Jane Smith',\n    itemId: '2',\n    itemName: 'Advanced Auth Plugin',\n    amount: -79.99,\n    currency: 'USD',\n    refundReason: 'Product not as described',\n    refundMethod: 'original_payment_method',\n    paymentProcessor: 'stripe',\n    refundId: 're_3OxGmXEv1LmQrGsV1qFqJKZv',\n    createdAt: new Date('2024-03-11T16:45:00Z'),\n    completedAt: new Date('2024-03-11T16:45:30Z'),\n    metadata: {\n      disputeId: 'dp_3OxGmXEv1LmQrGsV1qFqJKZv',\n      supportTicketId: 'ticket-789'\n    }\n  },\n  {\n    id: 'txn-005',\n    type: 'sale',\n    status: 'completed',\n    buyerId: 'user-5',\n    buyerName: 'Charlie Brown',\n    sellerId: 'user-1', // Current user's sale\n    sellerName: 'John Doe',\n    itemId: '1',\n    itemName: 'Vue CLI Template Pro',\n    itemType: 'template',\n    amount: 49.99,\n    currency: 'USD',\n    platformFee: 5.00,\n    sellerAmount: 44.99,\n    paymentMethod: 'cryptocurrency',\n    paymentProcessor: 'coinbase',\n    paymentIntentId: 'coinbase_txn_ghi012',\n    createdAt: new Date('2024-03-09T11:30:00Z'),\n    completedAt: new Date('2024-03-09T11:45:00Z'),\n    escrowReleaseDate: new Date('2024-03-16T11:30:00Z'),\n    metadata: {\n      cryptoCurrency: 'USDC',\n      walletAddress: '0x742d35Cc6634C0532925a3b8D6e4FA87C4A6C3A7',\n      downloadCount: 5,\n      licenseKey: 'lic_vue_template_jkl345'\n    }\n  }\n]\n\nexport default defineEventHandler(async (event) => {\n  try {\n    // Check authentication\n    const authHeader = getHeader(event, 'authorization')\n    if (!authHeader?.startsWith('Bearer ')) {\n      throw createError({\n        statusCode: 401,\n        statusMessage: 'Authorization required to view transactions'\n      })\n    }\n\n    const token = authHeader.substring(7)\n    const user = verifyToken(token)\n\n    const query = await getValidatedQuery(event, transactionQuerySchema.parse)\n    \n    // Filter transactions for current user (buyer or seller)\n    let transactions = mockTransactions.filter(txn => \n      txn.buyerId === user.id || txn.sellerId === user.id\n    )\n    \n    // Apply status filter\n    if (query.status !== 'all') {\n      transactions = transactions.filter(txn => txn.status === query.status)\n    }\n    \n    // Apply type filter\n    if (query.type !== 'all') {\n      transactions = transactions.filter(txn => txn.type === query.type)\n    }\n    \n    // Apply date filters\n    if (query.dateFrom) {\n      const fromDate = new Date(query.dateFrom)\n      transactions = transactions.filter(txn => txn.createdAt >= fromDate)\n    }\n    \n    if (query.dateTo) {\n      const toDate = new Date(query.dateTo)\n      transactions = transactions.filter(txn => txn.createdAt <= toDate)\n    }\n    \n    // Apply amount filters\n    if (query.minAmount !== undefined) {\n      transactions = transactions.filter(txn => Math.abs(txn.amount) >= query.minAmount!)\n    }\n    \n    if (query.maxAmount !== undefined) {\n      transactions = transactions.filter(txn => Math.abs(txn.amount) <= query.maxAmount!)\n    }\n    \n    // Apply sorting\n    transactions.sort((a, b) => {\n      let comparison = 0\n      \n      switch (query.sortBy) {\n        case 'date':\n          comparison = a.createdAt.getTime() - b.createdAt.getTime()\n          break\n        case 'amount':\n          comparison = Math.abs(a.amount) - Math.abs(b.amount)\n          break\n        case 'status':\n          comparison = a.status.localeCompare(b.status)\n          break\n      }\n      \n      return query.sortOrder === 'desc' ? -comparison : comparison\n    })\n    \n    // Apply pagination\n    const startIndex = (query.page - 1) * query.limit\n    const endIndex = startIndex + query.limit\n    const paginatedTransactions = transactions.slice(startIndex, endIndex)\n    \n    // Enrich transactions with computed fields\n    const enrichedTransactions = paginatedTransactions.map(txn => {\n      const userRole = txn.buyerId === user.id ? 'buyer' : 'seller'\n      const counterpartyName = userRole === 'buyer' ? txn.sellerName : txn.buyerName\n      \n      return {\n        ...txn,\n        userRole,\n        counterpartyName,\n        displayAmount: txn.amount,\n        netAmount: userRole === 'seller' \n          ? (txn.sellerAmount || txn.amount - (txn.platformFee || 0))\n          : txn.amount,\n        canRefund: canRefundTransaction(txn, user.id),\n        canDownload: canDownloadItem(txn, user.id),\n        statusColor: getStatusColor(txn.status),\n        formattedDate: txn.createdAt.toLocaleDateString(),\n        daysSinceTransaction: Math.floor(\n          (Date.now() - txn.createdAt.getTime()) / (1000 * 60 * 60 * 24)\n        )\n      }\n    })\n    \n    // Calculate summary statistics\n    const userTransactions = mockTransactions.filter(txn => \n      txn.buyerId === user.id || txn.sellerId === user.id\n    )\n    \n    const purchases = userTransactions.filter(txn => txn.buyerId === user.id && txn.amount > 0)\n    const sales = userTransactions.filter(txn => txn.sellerId === user.id && txn.amount > 0)\n    \n    const summary = {\n      totalPurchases: purchases.length,\n      totalSales: sales.length,\n      totalSpent: purchases.reduce((sum, txn) => sum + txn.amount, 0),\n      totalEarned: sales.reduce((sum, txn) => sum + (txn.sellerAmount || 0), 0),\n      pendingTransactions: userTransactions.filter(txn => txn.status === 'pending').length,\n      completedTransactions: userTransactions.filter(txn => txn.status === 'completed').length,\n      totalRefunds: userTransactions.filter(txn => txn.type === 'refund').length\n    }\n    \n    // Generate status distribution for charts\n    const statusDistribution = {\n      completed: transactions.filter(txn => txn.status === 'completed').length,\n      pending: transactions.filter(txn => txn.status === 'pending').length,\n      failed: transactions.filter(txn => txn.status === 'failed').length,\n      cancelled: transactions.filter(txn => txn.status === 'cancelled').length,\n      refunded: transactions.filter(txn => txn.status === 'refunded').length\n    }\n    \n    return {\n      success: true,\n      data: {\n        transactions: enrichedTransactions,\n        pagination: {\n          page: query.page,\n          limit: query.limit,\n          total: transactions.length,\n          totalPages: Math.ceil(transactions.length / query.limit),\n          hasNext: endIndex < transactions.length,\n          hasPrev: query.page > 1\n        },\n        summary,\n        analytics: {\n          statusDistribution,\n          monthlyVolume: calculateMonthlyVolume(userTransactions),\n          topCategories: getTopCategories(userTransactions)\n        }\n      }\n    }\n    \n  } catch (error: any) {\n    console.error('Get transactions error:', error)\n    \n    if (error.statusCode) {\n      throw error\n    }\n    \n    if (error.name === 'ZodError') {\n      throw createError({\n        statusCode: 400,\n        statusMessage: 'Invalid query parameters',\n        data: error.errors\n      })\n    }\n    \n    throw createError({\n      statusCode: 500,\n      statusMessage: 'Transaction service error'\n    })\n  }\n})\n\nfunction canRefundTransaction(transaction: any, userId: string): boolean {\n  // Buyers can request refunds within 7 days for completed purchases\n  if (transaction.buyerId !== userId) return false\n  if (transaction.status !== 'completed') return false\n  if (transaction.type === 'refund') return false\n  \n  const daysSince = (Date.now() - transaction.createdAt.getTime()) / (1000 * 60 * 60 * 24)\n  return daysSince <= 7\n}\n\nfunction canDownloadItem(transaction: any, userId: string): boolean {\n  // Buyers can download purchased items if transaction is completed\n  return transaction.buyerId === userId && transaction.status === 'completed'\n}\n\nfunction getStatusColor(status: string): string {\n  const colors = {\n    completed: 'green',\n    pending: 'yellow',\n    failed: 'red',\n    cancelled: 'gray',\n    refunded: 'blue'\n  }\n  return colors[status as keyof typeof colors] || 'gray'\n}\n\nfunction calculateMonthlyVolume(transactions: any[]): any[] {\n  const monthlyData = new Map()\n  \n  transactions.forEach(txn => {\n    if (txn.status === 'completed' && txn.amount > 0) {\n      const monthKey = txn.createdAt.toISOString().substring(0, 7) // YYYY-MM\n      const current = monthlyData.get(monthKey) || { month: monthKey, volume: 0, count: 0 }\n      current.volume += Math.abs(txn.amount)\n      current.count += 1\n      monthlyData.set(monthKey, current)\n    }\n  })\n  \n  return Array.from(monthlyData.values()).sort((a, b) => a.month.localeCompare(b.month))\n}\n\nfunction getTopCategories(transactions: any[]): any[] {\n  const categoryData = new Map()\n  \n  transactions.forEach(txn => {\n    if (txn.status === 'completed' && txn.itemType) {\n      const current = categoryData.get(txn.itemType) || { category: txn.itemType, volume: 0, count: 0 }\n      current.volume += Math.abs(txn.amount)\n      current.count += 1\n      categoryData.set(txn.itemType, current)\n    }\n  })\n  \n  return Array.from(categoryData.values())\n    .sort((a, b) => b.volume - a.volume)\n    .slice(0, 5)\n}